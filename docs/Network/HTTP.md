# HTTP

## TCP/IP 的分层管理

**应用层**，决定向用户**提供应用服务时的通信活动**。HTTP、FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名解析系统）都属于该层。

**传输层**，相对于上一层的应用层，该层**提供处于网络连接中的两台计算机的数据传输**。该层协议主要是 TCP（Transmission Control Protocol） 和 UDP（User Data Protocol）。

**网络层**，用于**处理网络上流动的数据包**（数据传输的最小单位），该层规定了通过怎样的路径到达对方计算机，并把数据传送给对方。该层协议主要是 IP 协议和 ARP（Address Solution Protocol） 协议。

**链路层**，用于**处理网络连接的硬件部分**，包括操作系统、设备驱动等，硬件上的范畴基本都在链路层的范围内。该层主要协议为以太网协议（Ethernet）。

**在传输过程的每一层中，都会对数据进行装箱和拆箱。**

**IP 协议负责网络传输，处于网络层。**

**TCP 位于传输层，提供可靠的字节流服务。TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有状态。 UDP是面向无连接的传输层协议。**

**DNS 也位于应用层，它提供域名解析服务。能够把域名解析为 IP 地址。**

**请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的**。

**响应报文基本上由协议版本、状态码（表示请求成功或者失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成**。

## HTTP 是无状态协议

HTTP 是一种不保存状态，即无状态（stateless）的协议。HTTP 自身不对请求和响应之间的通信状态进行保存。每次有新的请求建立时，就会有对应的响应产生，与之前或者之后的请求都没有任何关系。

### 持久连接

持久连接的特点是只要任意一方没有提出断开 TCP 连接，就会一直维持 TCP 的连接状态。

### 管线化

持久连接使得多数请求以管线化（pipeline）方式发送成为可能。以前发送请求后需要等待响应之后才能发送下一个请求，但是管线化技术出现后，不同等待响应就可以发起下一个请求，这样能够做到多个请求并行发送，大大减少了页面加载的时间。

### 使用 Cookie 管理状态

HTTP 是无状态协议，我们通过 Cookie 维持客户端状态。

Cookie 会根据从服务端发送的响应报文内的一个叫做 `Set-Cookie` 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。

## HTTP状态码
**200 ----- 表示从客户端发送的请求被服务器正常处理了。**

**204 ----- 服务器正常处理了，但是没有返回的内容。**

表示从客户端发送的请求被服务器正常处理了。

**206 ----- 客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。**

**301 ----- 永久性重定向。**

**302 ----- 临时重定向。**

**303 ----- 由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。（Location）**

**304 ----- 重定向，直接使用客户端缓存的资源。（协商缓存命中）**

**307 ----- 临时重定向。不允许HTTP方法更改。**

**308 ----- 永久重定向。不允许HTTP方法更改。**

**400 ----- 请求报文中存在语法错误。**

**401 ----- 请求需要通过认证，比如未登陆。**

**403 ----- 请求资源的访问被服务器拒绝了，比如法律禁止、信息敏感。**

**404 ----- 服务器上无法找到请求的资源。**

**405 ----- 请求方法不被服务器端允许。**

**500 ----- 服务端在执行请求时存在错误。**

**501 ----- 服务器不支持当前请求所需要的某个功能。**

**503 ----- 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。**

## 代理、网关和隧道

HTTP 通信时，除服务端和客户端以外，还有一些用于通信数据转发处理的**应用程序**，例如代理、网关和隧道，它们可以配合服务器工作。

- **代理**是一种有转发功能的应用程序，扮演者服务器和客户端的中间人的角色。代理接受客户端的请求转发给服务器，然后接受服务器的响应转发给客户端。
- **网关**是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。
- **隧道**是在相隔甚远的客户端和服务器之间进行中转并保持双方连接的应用程序。

## HTTP 首部字段类型

**通用首部字段**：请求报文和响应报文都会使用到的首部字段。

**请求首部字段**：从客户端向服务端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级的信息。

**响应首部字段**：从服务端向客户端发送响应报文时的首部。补充了响应的附加内容，也会要求客户端附加的内容信息。

**实体首部字段**：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体内容相关的信息。

## 其他概念
### UDP（User Data Protocol，用户数据报协议）
**UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。**

#### 面向无连接
首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。

#### 不可靠性
首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。

再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

#### 高效
UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。

### options请求
options是预检请求，在真正的请求发送出去之前，浏览器会先发送一个options请求向服务询问此接口是否允许我访问。

浏览器在当前真实请求是**非简单请求且跨域**的情况下会发起options预检请求。

简单请求：请求方法为get，post，head之一 且 Content-Type 的值为 text/plain、multipart/form-data、application/x-www-form-urlencoded之一。

### WebSocket
WebSocket则提供使用一个TCP连接进行双向通讯的机制，一种在**单个TCP连接上进行全双工通信**的协议。WebSocket基于HTTP协议，借用了HTTP的协议来完成一部分握手，WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成**一次握手**，两者之间就直接可以创建**持久性的连接**，并进行**双向数据传输**。

WebSocket和Ajax的区别
1. **本质不同**：Ajax,即异步JavaScript和XML，是一种创建交互式网页应用的网页开发技术；WebSocket是HTML5一种新的协议，实现了浏览器与服务器全双工通信。其本质是先通过HTTP/HTTPS协议进行握手后创建一个用于交换数据的TCP连接，服务端与客户端通过此TCP连接进行实时通信。

2. **生命周期不同**：WebSocket建立的是长连接，在一个会话中一直保持连接；而Ajax是短连接，数据发送和接受完成后就会断开连接。

3. **适用范围不同**：WebSocket一般用于前后端实时数据交互，而Ajax前后端非实时数据交互。