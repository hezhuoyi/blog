<!DOCTYPE html>
<html lang="zh-US">
  <head>
    <link rel="manifest" href="/blog/manifest.webmanifest"><title>Fiber | Johnny's blog</title><meta name="description" content="认真分享和记录各类好文，逐步完善大前端知识体系。"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="preload" href="/blog/assets/js/runtime~app.5b40ce10.js" as="script"><link rel="preload" href="/blog/assets/css/styles.678e5aee.css" as="style"><link rel="preload" href="/blog/assets/js/981.9765ac40.js" as="script"><link rel="preload" href="/blog/assets/js/app.3e27996d.js" as="script">
    <link rel="stylesheet" href="/blog/assets/css/styles.678e5aee.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a href="/blog/" class=""><!----><span class="site-name">Johnny&#39;s blog</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/blog/JavaScript/" class="nav-link" aria-label="深入JavaScript"><!--[--><!--]--> 深入JavaScript <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/Network/" class="nav-link" aria-label="计算机网络"><!--[--><!--]--> 计算机网络 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/Browser/" class="nav-link" aria-label="浏览器相关"><!--[--><!--]--> 浏览器相关 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/Framework/" class="nav-link router-link-active" aria-label="框架和类库"><!--[--><!--]--> 框架和类库 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/Engineering/" class="nav-link" aria-label="前端工程化"><!--[--><!--]--> 前端工程化 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/NewTechnology/" class="nav-link" aria-label="新技术/方向"><!--[--><!--]--> 新技术/方向 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://hezhuoyi.github.io/leetcode" rel="noopener noreferrer" target="_blank" aria-label="LeetCode"><!--[--><!--]--> LeetCode <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/hezhuoyi" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://juejin.cn/user/3597257778155703" rel="noopener noreferrer" target="_blank" aria-label="掘金"><!--[--><!--]--> 掘金 <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="Search" autocomplete="off" spellcheck="false" value><!----></form></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/blog/JavaScript/" class="nav-link" aria-label="深入JavaScript"><!--[--><!--]--> 深入JavaScript <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/Network/" class="nav-link" aria-label="计算机网络"><!--[--><!--]--> 计算机网络 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/Browser/" class="nav-link" aria-label="浏览器相关"><!--[--><!--]--> 浏览器相关 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/Framework/" class="nav-link router-link-active" aria-label="框架和类库"><!--[--><!--]--> 框架和类库 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/Engineering/" class="nav-link" aria-label="前端工程化"><!--[--><!--]--> 前端工程化 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/NewTechnology/" class="nav-link" aria-label="新技术/方向"><!--[--><!--]--> 新技术/方向 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://hezhuoyi.github.io/leetcode" rel="noopener noreferrer" target="_blank" aria-label="LeetCode"><!--[--><!--]--> LeetCode <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/hezhuoyi" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://juejin.cn/user/3597257778155703" rel="noopener noreferrer" target="_blank" aria-label="掘金"><!--[--><!--]--> 掘金 <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item active">框架和类库</p><ul class=""><li><!--[--><a href="/blog/Framework/" class="nav-link router-link-active sidebar-item" aria-label="概览"><!--[--><!--]--> 概览 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><p class="sidebar-item">Vue</p><ul class="sidebar-sub-items"><li><!--[--><a href="/blog/Framework/Vue/Vue%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="nav-link sidebar-item" aria-label="Vue实现原理"><!--[--><!--]--> Vue实现原理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/Vue/Vue%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3.html" class="nav-link sidebar-item" aria-label="Vue源码相关"><!--[--><!--]--> Vue源码相关 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/Vue/Vuex%E5%92%8CVue-Router.html" class="nav-link sidebar-item" aria-label="Vuex和Vue-Router"><!--[--><!--]--> Vuex和Vue-Router <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/Vue/Vue3%E7%9A%84%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-item" aria-label="Vue3的优化"><!--[--><!--]--> Vue3的优化 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><p class="sidebar-item active">React</p><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/blog/Framework/React/Fiber.html" class="router-link-active router-link-exact-active nav-link router-link-active sidebar-item active" aria-label="Fiber"><!--[--><!--]--> Fiber <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/blog/Framework/React/Fiber.html#fiber架构" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Fiber架构"><!--[--><!--]--> Fiber架构 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/blog/Framework/React/Fiber.html#关于时间切片" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="关于时间切片"><!--[--><!--]--> 关于时间切片 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/blog/Framework/React/Fiber.html#react的diff" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="React的diff"><!--[--><!--]--> React的diff <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/blog/Framework/React/Fiber.html#优化策略" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="优化策略"><!--[--><!--]--> 优化策略 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a href="/blog/Framework/React/Hooks.html" class="nav-link sidebar-item" aria-label="Hooks"><!--[--><!--]--> Hooks <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/React/Redux.html" class="nav-link sidebar-item" aria-label="Redux"><!--[--><!--]--> Redux <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/React/React%E5%85%B6%E4%BB%96.html" class="nav-link sidebar-item" aria-label="React其他"><!--[--><!--]--> React其他 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><p class="sidebar-item">TypeScript</p><ul class="sidebar-sub-items"><li><!--[--><a href="/blog/Framework/TypeScript/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TS.html" class="nav-link sidebar-item" aria-label="深入理解TS"><!--[--><!--]--> 深入理解TS <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/TypeScript/TS%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html" class="nav-link sidebar-item" aria-label="TS 类型系统"><!--[--><!--]--> TS 类型系统 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/TypeScript/%E5%B7%A7%E7%94%A8TypeScript.html" class="nav-link sidebar-item" aria-label="巧用TypeScript"><!--[--><!--]--> 巧用TypeScript <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><p class="sidebar-item">小程序</p><ul class="sidebar-sub-items"><li><!--[--><a href="/blog/Framework/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html" class="nav-link sidebar-item" aria-label="运行机制"><!--[--><!--]--> 运行机制 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><p class="sidebar-item">RN</p><ul class="sidebar-sub-items"><li><!--[--><a href="/blog/Framework/RN/%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html" class="nav-link sidebar-item" aria-label="基本概念"><!--[--><!--]--> 基本概念 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/RN/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html" class="nav-link sidebar-item" aria-label="启动流程"><!--[--><!--]--> 启动流程 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/RN/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/RN/%E6%96%B0%E6%9E%B6%E6%9E%84.html" class="nav-link sidebar-item" aria-label="新架构"><!--[--><!--]--> 新架构 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><p class="sidebar-item">Flutter</p><ul class="sidebar-sub-items"><li><!--[--><a href="/blog/Framework/Flutter/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html" class="nav-link sidebar-item" aria-label="核心原理"><!--[--><!--]--> 核心原理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/blog/Framework/Flutter/UI%E7%B3%BB%E7%BB%9F.html" class="nav-link sidebar-item" aria-label="UI系统"><!--[--><!--]--> UI系统 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="fiber" tabindex="-1"><a class="header-anchor" href="#fiber" aria-hidden="true">#</a> Fiber</h1><p>背景: 由于浏览器它将 GUI 描绘，时间器处理，事件处理，JS 执行，远程资源加载统统放在一起。如果执行 js 的更新， 占用了太久的进程就会导致浏览器的动画没办法执行，或者 input 响应比较慢。</p><p>react fiber 使用了 2 个核心解决思想:</p><ul><li><strong>让渲染有优先级</strong></li><li><strong>可中断 React Fiber 将虚拟 DOM 的更新过程划分两个阶段</strong>，reconciler 调和阶段与 commit 阶段.</li></ul><p>一次更新过程会分为很多个分片完成, 所以可能一个任务还没有执行完, 就被另一个优先级更高的更新过程打断, 这时候, 低优先级的工作就完全作废, 然后等待机会重头到来.</p><h4 id="调度的过程" tabindex="-1"><a class="header-anchor" href="#调度的过程" aria-hidden="true">#</a> 调度的过程</h4><p>requestIdleCallback：<strong>首先 react 会根据任务的优先级去分配各自的过期时间</strong>. requestIdleCallback 在每一帧的多余时间(黄色的区域)调用. 调用 channel.port1.onmessage , 先去判断当前时间是否小于下一帧时间, 如果小于则代表我们<strong>有空余时间去执行任务</strong>, 如果大于就去执行过期任务,如果任务没过期. 这个任务就被丢到<strong>下一帧执行</strong>了.由于 requestIdleCallback 的兼容性问题, react 自己实现了一个 requestIdleCallback</p><h2 id="fiber架构" tabindex="-1"><a class="header-anchor" href="#fiber架构" aria-hidden="true">#</a> Fiber架构</h2><p>React Fiber是对React来说是一次革命，解决了React项目严重依赖于手工优化的痛点，<strong>通过系统级别的时间调度，实现划时代的性能优化</strong>。</p><p>JavaScript 是单线程运行的，同时只能做一件事情，这个和 <code>DOS</code> 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差。对于’前端框架‘来说，解决这种问题有三个方向:</p><ul><li>1️⃣ <strong>优化每个任务，让它有多快就多快。挤压CPU运算量</strong></li><li>2️⃣ <strong>快速响应用户</strong>，让用户觉得够快，不能阻塞用户的交互</li><li>3️⃣ 尝试 <strong>Worker 多线程</strong></li></ul><p>Vue 选择的是第1️⃣, 因为对于Vue来说，使用<code>模板</code>让它有了很多优化的空间(比如静态节点的分析)，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下<a href="https://www.yuque.com/vueconf/2019/gwn1z0" target="_blank" rel="noopener noreferrer">今年Vue Conf 尤雨溪的演讲<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>，非常棒!；而 React 选择了2️⃣ 。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。</p><p>为什么需要引入Fiber =&gt; <strong>React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成</strong>。(Reconcilation)，此期间React 会霸占着浏览器资源，一则会<strong>导致用户触发的事件得不到响应, 二则会导致掉帧</strong>，用户可以感知到这些卡顿。</p><p><strong>为了给用户制造一种应用很快的&#39;假象&#39;，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的&#39;进程&#39;，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率</strong>。</p><p><strong>所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 &#39;适时&#39;地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处</strong>:</p><ul><li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以<strong>得到更好的用户体验</strong>。这个在<a href="https://juejin.im/post/5d76f469f265da039a28aff7#heading-1" target="_blank" rel="noopener noreferrer">《「前端进阶」高性能渲染十万条数据(时间分片)》<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 以及司徒正美的<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener noreferrer">《React Fiber架构》<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 都做了相关实验</li><li>司徒正美在<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener noreferrer">《React Fiber架构》<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 也提到：<strong>🔴给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</strong>.</li></ul><p>React Fiber 的思想和协程的概念是契合的: <strong>🔴React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p><p><strong>主动让出机制</strong> -- 通过<code>requestIdleCallback</code>实现</p><p><strong>设置任务优先级</strong></p><ol><li>数据结构的调整 栈=&gt;链表</li></ol><p><strong>Fiber 就是我们所说的工作单元，performUnitOfWork(深度优先遍历)负责对 <code>Fiber</code> 进行操作，并按照深度遍历的顺序返回下一个 Fiber</strong>。</p><p><strong>因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的<code>Fiber</code>继续遍历下去</strong>。</p><p>2.两个阶段的拆分</p><p><strong>协调阶段</strong>: 可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为&#39;<code>副作用</code>(Effect)&#39; . 以下生命周期钩子会在协调阶段被调用：</p><p><strong>提交阶段</strong>: 将上一个阶段计算出来的需要处理的 <strong>副作用(Effects)</strong> 一次性执行了。<strong>这个阶段必须同步执行，不能被打断</strong>. 这些生命周期钩子在提交阶段被执行:</p><p>在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。</p><p><strong>更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞</strong>。=&gt;</p><p><strong>要让高优先级任务插队, 首先要保证状态更新的时序</strong>。=&gt;</p><p><strong>所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行</strong></p><h2 id="关于时间切片" tabindex="-1"><a class="header-anchor" href="#关于时间切片" aria-hidden="true">#</a> 关于时间切片</h2><p>为什么vue3去除了时间分片？=&gt; <strong>如果我们可以把更新做得足够快的话，理论上就不需要时间分片了</strong>。</p><p><img src="/blog/assets/img/time-slicing.06d6ac63.png" alt="时间切片"></p><p>Shared mutable state is the root of all evil（共享的可变状态是万恶之源）</p><p>JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。</p><p>Immutable Data是指一旦创建，就不能被更改的数据。对Immutable对象的修改都会返回新的Immutable对象。并且目前的Immutable库，都实现了结构共享，即<strong>如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享，避免了deepCopy把所有节点都复制一遍带来的性能损耗。</strong></p><h3 id="实现一个时间切片-将长任务分解成更小的任务-避免阻塞主进程。" tabindex="-1"><a class="header-anchor" href="#实现一个时间切片-将长任务分解成更小的任务-避免阻塞主进程。" aria-hidden="true">#</a> 实现一个时间切片：将长任务分解成更小的任务，避免阻塞主进程。</h3><p>通常同步代码执行超过 50 毫秒是一个很长的任务。长任务会阻塞主线程，导致页面卡顿，我们有两种解决方案，Web worker和Time slicing。我们应该尽量使用 web worker，但是 web worker 无法访问 DOM。所以我们需要把一个长任务拆分成小任务，分布在宏任务队列中。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code> <span class="token keyword">function</span> <span class="token function">ts</span> <span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> gen <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> gen <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>gen <span class="token operator">||</span> <span class="token keyword">typeof</span> gen<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token keyword">return</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">next</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> start <span class="token operator">=</span> performance<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      res <span class="token operator">=</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">.</span>done <span class="token operator">&amp;&amp;</span> performance<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start <span class="token operator">&lt;</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="react的diff" tabindex="-1"><a class="header-anchor" href="#react的diff" aria-hidden="true">#</a> React的diff</h2><h3 id="_1-同层比对策略" tabindex="-1"><a class="header-anchor" href="#_1-同层比对策略" aria-hidden="true">#</a> 1. 同层比对策略</h3><p><strong>只做同层级的比对，忽略跨层级的元素移动</strong>。</p><p>此时，性能已经大大的提升了，时间复杂度优化成 <code>O(n^2)</code>。另外，<strong>如果真出现跨层级移动时，会直接将旧元素删除，在新的位置重新创建，也能保证更新的准确行。但可能会导致状态的丢失。</strong></p><h3 id="_2-唯一标识策略" tabindex="-1"><a class="header-anchor" href="#_2-唯一标识策略" aria-hidden="true">#</a> 2. 唯一标识策略</h3><p>用 <code>type</code> + <code>key</code> 便可确切地识别出节点的准确位置，从而将时间复杂度优化成了 <code>O(n)</code>。</p><h3 id="_3-组件模式策略" tabindex="-1"><a class="header-anchor" href="#_3-组件模式策略" aria-hidden="true">#</a> 3. 组件模式策略</h3><p><strong>碎片化 虚拟DOM</strong>。</p><p><strong>子级列表的比对，才是整个 diff 算法中最核心且最考验性能的部分。</strong></p><p>列表比对 (<code>diffChildren</code>) 采用 <strong>两端比对算法 + Key值比对</strong> 算法，大大提高了 <code>Diff</code> 效率；</p><ul><li>优先从新旧列表的 <strong>两端</strong> 的 <strong>四个节点</strong> 开始进行 <strong>两两比对</strong>；</li><li>如果均不匹配，则尝试 <strong>key 值比对</strong>； <ul><li>如 <strong>key 值</strong> 匹配上，则移动并更新节点；</li><li>如 未匹配上，则在对应的位置上 <strong>新增新节点</strong>；</li></ul></li><li>最后全部比对完后，列表中 <strong>剩余的节点</strong> 执行 <strong>删除或新增</strong>；</li></ul><h3 id="实践建议" tabindex="-1"><a class="header-anchor" href="#实践建议" aria-hidden="true">#</a> 实践建议</h3><h4 id="_1-props的传递" tabindex="-1"><a class="header-anchor" href="#_1-props的传递" aria-hidden="true">#</a> 1.<code>props</code>的传递</h4><p><code>JSX</code> 中标签可以传递属性，最简单的方式就是 <strong>值传递</strong></p><h4 id="_2-渲染树结构稳定" tabindex="-1"><a class="header-anchor" href="#_2-渲染树结构稳定" aria-hidden="true">#</a> 2. 渲染树结构稳定</h4><p><code>diff</code> 算法采用的 <strong>同层比对</strong> 的策略，因此如果是跨层级的移动，就会 重新创建新节点并删除原来的节点，并不是真正的移动。所以保证 <strong>渲染树结构稳定</strong> 可以有效提高性能。</p><h4 id="_3-key-的使用" tabindex="-1"><a class="header-anchor" href="#_3-key-的使用" aria-hidden="true">#</a> 3. key 的使用</h4><p>当需要列表中 <code>VNode</code> 的 <strong>同层移动</strong> 时，加上唯一标识 <code>key</code> 能有效提高 <code>diff</code> 性能，避免元素的 <strong>重渲染</strong>。</p><h4 id="_4-组件化" tabindex="-1"><a class="header-anchor" href="#_4-组件化" aria-hidden="true">#</a> 4. 组件化</h4><ul><li><strong>复用性高</strong> 且需要 <strong>频繁更新</strong> 的节点抽离成 <strong>组件</strong>，会使 <code>VNode Tree</code> 碎片化，从而能更有效地进行 <strong>局部更新</strong>，减少触发 <code>diff</code> 的节点数量，提高性能且提高代码复用率；</li><li>但由于组件的创建和 <code>diff</code> 相比普通节点来说更为 <strong>复杂</strong>，需要执行例如生命周期，组件比对 等，所以需要 <strong>合理规划</strong>，避免 <strong>过分组件化</strong> 导致 <strong>内存的浪费和影响性能</strong>，一些 <strong>复用率低的静态元素</strong> 直接使用元素节点更为合理；</li></ul><h3 id="diff-策略" tabindex="-1"><a class="header-anchor" href="#diff-策略" aria-hidden="true">#</a> diff 策略</h3><ol><li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li><li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li><li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li></ol><p>基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。</p><h3 id="tree-diff" tabindex="-1"><a class="header-anchor" href="#tree-diff" aria-hidden="true">#</a> tree diff</h3><p>基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。</p><h3 id="component-diff" tabindex="-1"><a class="header-anchor" href="#component-diff" aria-hidden="true">#</a> component diff</h3><p>React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。</p><ul><li>如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。</li><li>如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。</li><li>对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。</li></ul><h3 id="element-diff" tabindex="-1"><a class="header-anchor" href="#element-diff" aria-hidden="true">#</a> element diff</h3><p>当节点处于同一层级时，React diff 提供了三种节点操作，分别为：<strong>INSERT_MARKUP</strong>（插入）、<strong>MOVE_EXISTING</strong>（移动）和 <strong>REMOVE_NODE</strong>（删除）。</p><ul><li><strong>INSERT_MARKUP</strong>，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。</li><li><strong>MOVE_EXISTING</strong>，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。</li><li><strong>REMOVE_NODE</strong>，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。</li></ul><p>React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！</p><p>那么，如此高效的 diff 到底是如何运作的呢？让我们通过源码进行详细分析。</p><p>首先对新集合的节点进行循环遍历，for (name in nextChildren)，<strong>通过唯一 key 可以判断新老集合中是否存在相同的节点</strong>，if (prevChild === nextChild)，如果存在相同节点，则进行移动操作，但在移动前需要将当前节点在老集合中的位置与 lastIndex 进行比较，if (child._mountIndex &lt; lastIndex)，则进行节点移动操作，否则不执行该操作。这是一种<strong>顺序优化手段</strong>，lastIndex 一直在更新，表示访问过的节点在老集合中最右的位置（即最大的位置），<strong>如果新集合中当前访问的节点比 lastIndex 大，说明当前访问节点在老集合中就比上一个节点位置靠后，则该节点不会影响其他节点的位置，因此不用添加到差异队列中，即不执行移动操作，只有当访问的节点比 lastIndex 小时，才需要进行移动操作。</strong></p><p>建议：在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</p><h3 id="vue和react的diff算法的区别" tabindex="-1"><a class="header-anchor" href="#vue和react的diff算法的区别" aria-hidden="true">#</a> vue和react的diff算法的区别</h3><p>vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。</p><ol><li><p>vue比对节点，当<strong>节点元素类型相同，但是className不同</strong>，认为是<strong>不同类型</strong>元素，删除重建，而react会认为是<strong>同类型节点</strong>，只是修改节点属性</p></li><li><p>vue的列表比对，采用<strong>从两端到中间的比对方式，而react则采用从左到右依次比对</strong>的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个。总体上，vue的对比方式更高效。</p></li></ol><h2 id="优化策略" tabindex="-1"><a class="header-anchor" href="#优化策略" aria-hidden="true">#</a> 优化策略</h2><p>回到性能优化这个点，从这里的简单实现我们可以看出: 虽然异步化了更新流程，但本质上仍然没有解决 复杂的组件 <code>diff</code> 带来长时间执行阻塞主进程。我记得以前文章有说过: <strong>最有效的性能优化方式就是 异步、任务分割 和 缓存策略。</strong></p><h3 id="_1-异步化" tabindex="-1"><a class="header-anchor" href="#_1-异步化" aria-hidden="true">#</a> 1. 异步化:</h3><p>通过把同步的代码执行变成异步，把串行变成并行，可以有效提高 <strong>执行的时间利用率</strong> 和 <strong>保证代码优先级</strong>。从这里可以延伸出两种优化方向:</p><ul><li><ol><li><strong>异步</strong>: 如我们上面所做的优化，这样能保证主进程的执行优先级，保证页面渲染或者更主要任务的优先执行，避免卡顿；</li></ol></li><li><ol><li><strong>并行</strong>: 通过把某些高消耗的操作放到 <strong>非主进程</strong> 上执行，例如 worker 线程。不过由于 <code>diff</code> 本身就较为复杂，还要需要处理好主进程与线程之间的交互，会导致复杂度极高，但也并非不可行，后续也许是个优化方向。</li></ol><ul><li>例如我就在思考在这里引入 wasm 的可能性，代价与收益比如何，有兴趣的童鞋可以一起探讨。</li></ul></li></ul><h3 id="_2-任务分割" tabindex="-1"><a class="header-anchor" href="#_2-任务分割" aria-hidden="true">#</a> 2. 任务分割</h3><p>将原本会阻塞主进程的 <strong>大块逻辑执行进行拆解，分割成一个个小任务</strong>。从而可以在逻辑中找到合适的时机点 <strong>分段执行</strong>，即 <strong>不会阻塞主进程，又可以让代码快速高效的执行，最大化利用物理资源。</strong></p><p>Facebook 的大神们选择了这条优化方向，这就是 React 16 新引入的 <code>Fiber</code> 理念的最主要目的。上面我们实现的 <code>diff</code> 中，有着一个很大的障碍:</p><p><strong>一棵完整 虚拟DOM树 更新，必须一次性更新完成，中间无法被暂停，也无法被分割。</strong></p><p>而 <code>Fiber</code> 最主要的功能就是 <strong>指针映射，保存上一个更新的组件与下一步需要更新的组件</strong>，从而完成 <strong>可暂停可重启</strong>。计算进程的运行时间，利用浏览器的 <code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code> 接口，当有优先级更高的任务时，优先执行，暂停下一个组件的更新。待空闲时再重启更新。</p><p><strong>(window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。)</strong></p><p><strong>(window.requestAnimationFrame() 告诉浏览器—你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行)</strong></p><p><code>Fiber</code> 算是一种编程思想，在其它语言中也有许多应用(<code>Ruby Fiber</code>)。核心思想是:</p><p><strong>任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。</strong></p><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/blog/Framework/React/Hooks.html" class="nav-link" aria-label="Hooks"><!--[--><!--]--> Hooks <!--[--><!--]--></a> → </span></p></nav><!--[--><!--]--></main></div><!----><!--]--></div>
    <script src="/blog/assets/js/runtime~app.5b40ce10.js" defer></script><script src="/blog/assets/js/981.9765ac40.js" defer></script><script src="/blog/assets/js/app.3e27996d.js" defer></script>
  </body>
</html>
