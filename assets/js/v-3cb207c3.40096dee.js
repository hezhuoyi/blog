(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4137],{445:(e,o,s)=>{"use strict";s.r(o),s.d(o,{data:()=>r});const r={key:"v-3cb207c3",path:"/Framework/React/Hooks.html",title:"Hooks",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"hooks原理",slug:"hooks原理",children:[{level:3,title:"renderWithHooks函数",slug:"renderwithhooks函数",children:[]}]},{level:2,title:"关于hook性能优化常见方法",slug:"关于hook性能优化常见方法",children:[]},{level:2,title:"为什么要顺序调用hook",slug:"为什么要顺序调用hook",children:[]},{level:2,title:"使用tips",slug:"使用tips",children:[]}],filePathRelative:"Framework/React/Hooks.md"}},1311:(e,o,s)=>{"use strict";s.r(o),s.d(o,{default:()=>E});var r=s(6252);const n=s.p+"assets/img/hooks原理.e617bc0e.jpg",t=s.p+"assets/img/hooks-renderWithHooks.3721b5e3.jpg",l=s.p+"assets/img/hooks-初始化.850d5131.jpg",m=(0,r.Wm)("h1",{id:"hooks",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#hooks","aria-hidden":"true"},"#"),(0,r.Uk)(" Hooks")],-1),a=(0,r.Wm)("p",null,"解决什么问题：hooks就是函数组件解决没有state，生命周期，逻辑不能复用的一种技术方案。",-1),u=(0,r.Wm)("h2",{id:"hooks原理",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#hooks原理","aria-hidden":"true"},"#"),(0,r.Uk)(" hooks原理")],-1),k=(0,r.Wm)("p",null,[(0,r.Wm)("img",{src:n,alt:"hooks原理"})],-1),i=(0,r.Wm)("h3",{id:"renderwithhooks函数",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#renderwithhooks函数","aria-hidden":"true"},"#"),(0,r.Uk)(" renderWithHooks函数")],-1),c=(0,r.Wm)("p",null,"相关概念",-1),h=(0,r.Wm)("div",{class:"language-text ext-text line-numbers-mode"},[(0,r.Wm)("pre",{class:"language-text"},[(0,r.Wm)("code",null,"currentfiber树: 当完成一次渲染之后，会产生一个current树,current会在commit阶段替换成真实的Dom树。\nworkInProgressfiber树: 即将调和渲染的 fiber 树。再一次新的组件更新过程中，会从current复制一份作为workInProgress,更新完毕后，将当前的workInProgress树赋值给current树。\nworkInProgress.memoizedState: 在class组件中，memoizedState存放state信息，在function组件中，memoizedState在一次调和渲染过程中，以链表的形式存放hooks信息。\nworkInProgress.expirationTime: react用不同的expirationTime,来确定更新的优先级。\ncurrentHook: 可以理解 current树上的指向的当前调度的 hooks节点。\nworkInProgressHook: 可以理解 workInProgress树上指向的当前调度的 hooks节点。\n")]),(0,r.Wm)("div",{class:"line-numbers"},[(0,r.Wm)("span",{class:"line-number"},"1"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"2"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"3"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"4"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"5"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"6"),(0,r.Wm)("br")])],-1),W=(0,r.Wm)("p",null,"具体作用：",-1),d=(0,r.Wm)("div",{class:"language-text ext-text line-numbers-mode"},[(0,r.Wm)("pre",{class:"language-text"},[(0,r.Wm)("code",null,"1.置空workInProgress树的memoizedState和updateQueue，因为在接下来的函数组件的执行过程中，需要把新的hooks信息挂载上这两个属性，并在commit阶段将workInProgress树替换成current树，替换真实的DOM元素节点。并在current树保存hooks信息。\n2.给ReactCurrentDispatcher.current赋值，根据是否首次渲染，也就是根据current上是否有memoizedState（hook信息）判断。\n3.调用Component函数组件，依次执行hooks，并保存到workInProgress树上。\n4.重新置空一些变量比如currentHook，currentlyRenderingFiber,workInProgressHook。\n")]),(0,r.Wm)("div",{class:"line-numbers"},[(0,r.Wm)("span",{class:"line-number"},"1"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"2"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"3"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"4"),(0,r.Wm)("br")])],-1),p=(0,r.Wm)("p",null,[(0,r.Wm)("img",{src:t,alt:"hooks-renderWithHooks"})],-1),g=(0,r.Wm)("p",null,"每次hooks执行，都会调用mountWorkInProgressHook，这个函数会产生一个hook对象，保存当前hook信息，再将每个hooks以链表的形式串联起来，赋值给workInProgress.memoizedState。",-1),b=(0,r.Wm)("div",{class:"language-text ext-text line-numbers-mode"},[(0,r.Wm)("pre",{class:"language-text"},[(0,r.Wm)("code",null,"hook: {\n    memoizedState： useState中 保存 state 信息 ｜ useEffect 中 保存着 effect 对象 ｜ useMemo 中 保存的是缓存的值和 deps ｜ useRef 中保存的是 ref 对象。\n    baseQueue: usestate和useReducer中 保存最新的更新队列。\n    baseState： usestate和useReducer中,一次更新中 ，产生的最新state值。\n    queue： 保存待更新队列 pendingQueue ，更新函数 dispatch 等信息。\n    next: 指向下一个 hooks对象。\n}\n")]),(0,r.Wm)("div",{class:"line-numbers"},[(0,r.Wm)("span",{class:"line-number"},"1"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"2"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"3"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"4"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"5"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"6"),(0,r.Wm)("br"),(0,r.Wm)("span",{class:"line-number"},"7"),(0,r.Wm)("br")])],-1),f=(0,r.Wm)("p",null,[(0,r.Wm)("img",{src:l,alt:"hooks初始化"})],-1),w=(0,r.Wm)("p",null,[(0,r.Wm)("strong",null,"一旦在条件语句中声明hooks，在下一次函数组件更新，hooks链表结构，将会被破坏，current树的memoizedState缓存hooks信息，和当前workInProgress不一致，如果涉及到读取state等操作，就会发生异常。")],-1),x=(0,r.Wm)("p",null,"初始化阶段总结：初始化阶段,react-hooks做的事情，在一个函数组件第一次渲染执行上下文过程中，每个react-hooks执行，都会产生一个hook对象，并形成链表结构，绑定在workInProgress的memoizedState属性上，然后react-hooks上的状态，绑定在当前hooks对象的memoizedState属性上。对于effect副作用钩子，会绑定在workInProgress.updateQueue上，等到commit阶段，dom树构建完成，在执行每个 effect 副作用钩子。",-1),P=(0,r.Wm)("p",null,"更新阶段总结：每次函数组件更新，当再次执行hooks函数的时候，比如 useState(0) ，首先要从current的hooks中找到与当前workInProgressHook，对应的currentHooks，然后复制一份currentHooks给workInProgressHook,接下来hooks函数执行的时候,把最新的状态更新到workInProgressHook，保证hooks状态不丢失。由updateWorkInProgressHook函数完成。",-1),H=(0,r.Wm)("h2",{id:"关于hook性能优化常见方法",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#关于hook性能优化常见方法","aria-hidden":"true"},"#"),(0,r.Uk)(" 关于hook性能优化常见方法")],-1),I=(0,r.Wm)("p",null,[(0,r.Uk)("React.memo("),(0,r.Wm)("code",null,"<Component />"),(0,r.Uk)(") 原理和PureComponent一致")],-1),U=(0,r.Wm)("p",null,[(0,r.Uk)("React.memo默认情况下其只会对 props 的复杂对象做"),(0,r.Wm)("strong",null,"浅层对比"),(0,r.Uk)("(浅层对比就是只会对比前后两次 "),(0,r.Wm)("strong",null,"props"),(0,r.Uk)(" 对象引用是否相同，不会对比对象里面的内容是否相同)，如果你想要控制对比过程，那么请将"),(0,r.Wm)("strong",null,"自定义的比较函数"),(0,r.Uk)("通过第二个参数传入来实现。")],-1),S=(0,r.Wm)("p",null,"如何保持局部不变",-1),R=(0,r.Wm)("p",null,[(0,r.Wm)("strong",null,"const data = useMemo(() => [], [])")],-1),v=(0,r.Wm)("p",null,[(0,r.Wm)("strong",null,"通过 useMemo 将引用存储起来，依赖不变引用也就不变。避免当父组件渲染的时候虽然有属性没有变，但是 该属性的引用已经变了。props传递给子组件的时候，如果即使使用了 React.memo但是性能优化也会失效。")],-1),z=(0,r.Wm)("p",null,[(0,r.Uk)("对于函数来说，想要保存它的引用可以使用 "),(0,r.Wm)("code",null,"useCallback"),(0,r.Uk)(" 。")],-1),C=(0,r.Wm)("p",null,[(0,r.Wm)("strong",null,"const onIncrement = useCallback(() => { setCount(count => count + 1) }, []) 避免频繁创建及销毁函数")],-1),M=(0,r.Wm)("h2",{id:"为什么要顺序调用hook",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#为什么要顺序调用hook","aria-hidden":"true"},"#"),(0,r.Uk)(" 为什么要顺序调用hook")],-1),j=(0,r.Wm)("p",null,"官方有句话，必须顺序调用hook。衍生的其他规则：不要在if条件判断中使用hook、必须在函数组件内使用hook、不要在循环中使用hook（其实只要保证循环每次都完全一样还是可以的）",-1),Q=(0,r.Wm)("p",null,[(0,r.Wm)("strong",null,"React 会在第一次渲染时将每个 hook 按顺序放入 Hooks 数组中，下次渲染时，同样的hooks以相同的顺序被调用，所以React可以查看它的数组，并发现已经在位置0有一个useState hook ，所以React不会创建一个新状态，而是返回现有状态。")],-1),y=(0,r.Wm)("p",null,[(0,r.Uk)("这就是React能够在"),(0,r.Wm)("strong",null,"多个函数调用中创建和维护状态的方式"),(0,r.Uk)("，即使变量本身每次都超出作用域。")],-1),D=(0,r.Wm)("h2",{id:"使用tips",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#使用tips","aria-hidden":"true"},"#"),(0,r.Uk)(" 使用tips")],-1),F=(0,r.Wm)("ol",null,[(0,r.Wm)("li",null,"hooks中useEffect方法第二个参数是用全等判断是否相等 如果是引用类型数据 则每次都会触发副作用 （可用JSON.stringify）"),(0,r.Wm)("li",null,"memo：第二个方法参数更精确控制重新渲染（不加的话只会浅比较）"),(0,r.Wm)("li",null,"useMemo：传递一个创建函数和一个依赖数组，然后返回一个记忆化的值。当依赖发生变化的时候（浅比较），useMemo 将重新计算记忆化值。这个优化可以帮助避免每次渲染的时候昂贵地计算。useMemo相当于在组件内部更细粒度控制更新逻辑 （如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值 第二个参数为空数组，则只会在渲染组件时执行一次）")],-1),E={render:function(e,o){return(0,r.wg)(),(0,r.j4)(r.HY,null,[m,a,u,k,i,c,h,W,d,p,g,b,f,w,x,P,H,I,U,S,R,v,z,C,M,j,Q,y,D,F],64)}}}}]);