(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2651],{2467:(n,a,e)=>{"use strict";e.r(a),e.d(a,{data:()=>s});const s={key:"v-160583b5",path:"/JavaScript/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.html",title:"内存泄露",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"垃圾回收机制",slug:"垃圾回收机制",children:[{level:3,title:"V8 下的垃圾回收机制",slug:"v8-下的垃圾回收机制",children:[]},{level:3,title:"新生代算法",slug:"新生代算法",children:[]},{level:3,title:"老生代算法",slug:"老生代算法",children:[]},{level:3,title:"JS GC 策略",slug:"js-gc-策略",children:[]}]}],filePathRelative:"JavaScript/内存泄露.md"}},2591:(n,a,e)=>{"use strict";e.r(a),e.d(a,{default:()=>d});var s=e(6252);const t=(0,s.uE)('<h1 id="内存泄露" tabindex="-1"><a class="header-anchor" href="#内存泄露" aria-hidden="true">#</a> 内存泄露</h1><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。</p><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><p>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</p><p>有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。</p><p>大多数语言提供自动内存管理，减轻程序员的负担，这被称为&quot;垃圾回收机制&quot;（garbage collector）。</p><h2 id="垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#垃圾回收机制" aria-hidden="true">#</a> 垃圾回收机制</h2><h3 id="v8-下的垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#v8-下的垃圾回收机制" aria-hidden="true">#</a> V8 下的垃圾回收机制</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p><h3 id="新生代算法" tabindex="-1"><a class="header-anchor" href="#新生代算法" aria-hidden="true">#</a> 新生代算法</h3><p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p><p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p><h3 id="老生代算法" tabindex="-1"><a class="header-anchor" href="#老生代算法" aria-hidden="true">#</a> 老生代算法</h3><p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p><p>在老生代中，以下情况会先启动标记清除算法：</p><ol><li>某一个空间没有分块的时候</li><li>空间中被对象超过一定限制</li><li>空间不能保证新生代中的对象移动到老生代中</li></ol><p>在这个阶段中，<strong>会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象</strong>。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。</p><p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p><h3 id="js-gc-策略" tabindex="-1"><a class="header-anchor" href="#js-gc-策略" aria-hidden="true">#</a> JS GC 策略</h3><h4 id="引用计数-此算法已经废弃" tabindex="-1"><a class="header-anchor" href="#引用计数-此算法已经废弃" aria-hidden="true">#</a> 引用计数（此算法已经废弃）</h4><p><strong>此算法无法解决循环引用的情况，容易造成内存泄漏。</strong></p>',21),r=(0,s.Uk)("最常使用的方法叫做"),l={href:"https://en.wikipedia.org/wiki/Reference_counting",target:"_blank",rel:"noopener noreferrer"},o=(0,s.Uk)('"引用计数"'),p=(0,s.Uk)('（reference counting）：语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是'),i=(0,s.Wm)("code",null,"0",-1),c=(0,s.Uk)("，就表示这个值不再用到了，因此可以将这块内存释放。"),u=(0,s.uE)('<ul><li>原理：每次引用加一，被释放时减一，当这个值的引用次数变成 0 时，就可以将其内存空间回收</li><li>缺点：循环引用(obj1 和 obj2 通过各自的属性相互引用，也就是说，这两个对象的引用次数都是 2)</li></ul><blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hello world&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\narr <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></blockquote><p>上面代码中，<code>arr</code>重置为<code>null</code>，就解除了对<code>[1, 2, 3, 4]</code>的引用，引用次数变成了<code>0</code>，内存就可以释放出来了。</p><p>因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。</p><h4 id="标记清除" tabindex="-1"><a class="header-anchor" href="#标记清除" aria-hidden="true">#</a> 标记清除</h4><p>​当变量进入执行环境时，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</p><p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p><ul><li>标记方式：特殊位的反转、维护一个列表</li><li>原理：垃圾收集器在<strong>运行的时候</strong>会给存储在内存中的所有变量都<strong>加上标记</strong>，然后它会<strong>去掉环境中的变量已经被环境中变量被标记为引用的变量</strong>，在此之后再被标记的变量将被视为准备删除的变量。最后垃圾回收器清除标记的变量，回收它们所占用的内存空间</li><li>目前<strong>主流浏览器</strong>都是使用标记清除式的垃圾回收策略，只不过收集的<strong>间隔有所不同</strong></li></ul>',8),d={render:function(n,a){const e=(0,s.up)("OutboundLink");return(0,s.wg)(),(0,s.j4)(s.HY,null,[t,(0,s.Wm)("p",null,[r,(0,s.Wm)("a",l,[o,(0,s.Wm)(e)]),p,i,c]),u],64)}}}}]);