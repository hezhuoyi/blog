(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6771],{7192:(e,r,a)=>{"use strict";a.r(r),a.d(r,{data:()=>n});const n={key:"v-2da3b590",path:"/Framework/RN/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",title:"性能优化",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"RN启动优化",slug:"rn启动优化",children:[{level:3,title:"1. Hermes引擎",slug:"_1-hermes引擎",children:[]},{level:3,title:"2. JS Bundle",slug:"_2-js-bundle",children:[]},{level:3,title:"3. Network 首屏加载优化",slug:"_3-network-首屏加载优化",children:[]},{level:3,title:"4.Render",slug:"_4-render",children:[]}]},{level:2,title:"RN性能优化",slug:"rn性能优化",children:[{level:3,title:"1. 减少 re-render",slug:"_1-减少-re-render",children:[]},{level:3,title:"2. 减轻渲染压力",slug:"_2-减轻渲染压力",children:[]},{level:3,title:"3.动画性能优化",slug:"_3-动画性能优化",children:[]},{level:3,title:"四、长列表性能优化",slug:"四、长列表性能优化",children:[]}]},{level:2,title:"RN性能常见问题",slug:"rn性能常见问题",children:[]},{level:2,title:"RN性能优化方案",slug:"rn性能优化方案",children:[]}],filePathRelative:"Framework/RN/性能优化.md"}},2253:(e,r,a)=>{"use strict";a.r(r),a.d(r,{default:()=>ke});var n=a(6252);const l=a.p+"assets/img/rn-problem.27c6a3d7.jpg",d=a.p+"assets/img/rn-optimize.ea058705.jpg",i=(0,n.Wm)("h1",{id:"性能优化",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#性能优化","aria-hidden":"true"},"#"),(0,n.Uk)(" 性能优化")],-1),t=(0,n.Wm)("h2",{id:"rn启动优化",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#rn启动优化","aria-hidden":"true"},"#"),(0,n.Uk)(" RN启动优化")],-1),h=(0,n.Wm)("h3",{id:"_1-hermes引擎",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_1-hermes引擎","aria-hidden":"true"},"#"),(0,n.Uk)(" 1. Hermes引擎")],-1),m=(0,n.Wm)("p",null,"支持直接加载字节码，省掉jsEngine解析编译JS的时间，JS 代码的加载速度将会大大加快",-1),u=(0,n.Wm)("h3",{id:"_2-js-bundle",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_2-js-bundle","aria-hidden":"true"},"#"),(0,n.Uk)(" 2. JS Bundle")],-1),s=(0,n.Wm)("h4",{id:"_2-1-减小-js-bundle-体积",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_2-1-减小-js-bundle-体积","aria-hidden":"true"},"#"),(0,n.Uk)(" 2.1 减小 JS Bundle 体积")],-1),W=(0,n.Wm)("p",null,"￼对于同样的功能，优先选择体积更小的第三方库",-1),c=(0,n.Wm)("p",null,"￼利用 babel 插件，避免全量引用",-1),o=(0,n.Wm)("p",null,"￼制定编码规范，减少重复代码",-1),p=(0,n.Wm)("h4",{id:"_2-2-inline-requires-懒执行-延迟运行",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_2-2-inline-requires-懒执行-延迟运行","aria-hidden":"true"},"#"),(0,n.Uk)(" 2.2 Inline Requires 懒执行（延迟运行）")],-1),b=(0,n.Wm)("p",null,"其实 Inline Requires 的原理非常简单，就是把 require 导入的位置改变了一下。使用时在加载。（Metro 打包 JS 时，会把 ESM 模块转为 CommonJS 模块）",-1),_=(0,n.Wm)("h4",{id:"_2-3-jsbundle-分包加载",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_2-3-jsbundle-分包加载","aria-hidden":"true"},"#"),(0,n.Uk)(" 2.3 JSBundle 分包加载")],-1),k=(0,n.Wm)("p",null,"将共有库打包到一个common.bundle文件里，每次只要动态下发业务包，然后再客户端实现先加载 common.bundle 文件，再加载 business.bundle 文件就可以了。",-1),f=(0,n.Wm)("p",null,"common.bundle 可以直接放在本地，省去多业务线的多次下载，节省流量和带宽",-1),U=(0,n.Wm)("p",null,"可以在 RN 容器预初始化的时候就加载 common.bundle ，二次加载的业务包体积更小，初始化速度更快",-1),v=(0,n.Wm)("p",null,"2.3.1 JS Bundle 拆包",-1),g=(0,n.Wm)("p",null,"拆包之前要先了解一下 Metro 这个打包工具的工作流程。Metro 的打包流程很简单，只有三个步骤：",-1),N=(0,n.Wm)("p",null,"Resolution：可以简单理解为分析各个模块的依赖关系，最后会生成一个依赖图",-1),R=(0,n.Wm)("p",null,"Transformation：代码的编译转换，主要是借助 Babel 的编译转换能力",-1),S=(0,n.Wm)("p",null,"Serialization：所有代码转换完毕后，打印转换后的代码，生成一个或者多个 bundle 文件",-1),x=(0,n.Wm)("p",null,"从上面流程可以看出，我们的拆包步骤只会在 Serialization 这一步。我们只要借助 Serialization 暴露的各个方法就可以实现 bundle 分包了。",-1),J=(0,n.Wm)("p",null,[(0,n.Wm)("strong",null,"在 createModuleIdFactory 中根据文件的相对路径构建 ModuleId")],-1),I=(0,n.Wm)("p",null,[(0,n.Wm)("strong",null,"在 processModuleFilter 中通过 moduleId 过滤在 common.bundle 里的数据")],-1),T=(0,n.Wm)("p",null,"2.3.2 Native 实现多 bundle 加载",-1),j=(0,n.Wm)("h3",{id:"_3-network-首屏加载优化",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_3-network-首屏加载优化","aria-hidden":"true"},"#"),(0,n.Uk)(" 3. Network 首屏加载优化")],-1),w=(0,n.Wm)("h4",{id:"_3-1-dns-缓存-提前缓存-ip-地址-跳过-dns-寻址时间",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_3-1-dns-缓存-提前缓存-ip-地址-跳过-dns-寻址时间","aria-hidden":"true"},"#"),(0,n.Uk)(" 3.1 DNS 缓存：提前缓存 IP 地址，跳过 DNS 寻址时间")],-1),M=(0,n.Wm)("h4",{id:"_3-2-缓存复用-进入-rn-页面前-先提前请求网络数据并缓存下来-打开-rn-页面后请求网络前先检查缓存数据-如果缓存未过期-直接从本地缓存里拿数据",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_3-2-缓存复用-进入-rn-页面前-先提前请求网络数据并缓存下来-打开-rn-页面后请求网络前先检查缓存数据-如果缓存未过期-直接从本地缓存里拿数据","aria-hidden":"true"},"#"),(0,n.Uk)(" 3.2 缓存复用：进入 RN 页面前，先提前请求网络数据并缓存下来，打开 RN 页面后请求网络前先检查缓存数据，如果缓存未过期，直接从本地缓存里拿数据")],-1),P=(0,n.Wm)("h4",{id:"_3-3-请求合并-如果还在用-http-1-1-若首屏有多个请求-可以合并多个请求为一个请求",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_3-3-请求合并-如果还在用-http-1-1-若首屏有多个请求-可以合并多个请求为一个请求","aria-hidden":"true"},"#"),(0,n.Uk)(" 3.3 请求合并：如果还在用 HTTP/1.1，若首屏有多个请求，可以合并多个请求为一个请求")],-1),B=(0,n.Wm)("h4",{id:"_3-4-http2-利用-http2-的并行请求和多路复用优化速度",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_3-4-http2-利用-http2-的并行请求和多路复用优化速度","aria-hidden":"true"},"#"),(0,n.Uk)(" 3.4 HTTP2：利用 HTTP2 的并行请求和多路复用优化速度")],-1),D=(0,n.Wm)("h4",{id:"_3-5-减小体积-去除接口的冗余字段-减少图片资源的体积等等",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_3-5-减小体积-去除接口的冗余字段-减少图片资源的体积等等","aria-hidden":"true"},"#"),(0,n.Uk)(" 3.5 减小体积：去除接口的冗余字段，减少图片资源的体积等等")],-1),C=(0,n.Wm)("h3",{id:"_4-render",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_4-render","aria-hidden":"true"},"#"),(0,n.Uk)(" 4.Render")],-1),O=(0,n.Wm)("p",null,"渲染这里的耗时，基本上和首屏页面的 UI 复杂度成正相关。可以通过渲染流程查看哪里会出现耗时：",-1),H=(0,n.Wm)("p",null,"VDOM 计算：页面复杂度越高，JavaScript 侧的计算耗时就会越长（VDOM 的生成与 Diff）",-1),E=(0,n.Wm)("p",null,"JS Native 通讯：JS 的计算结果会转为 JSON 通过 Bridge 传递给 Native 侧，复杂度越高，JSON 的数据量越大，有可能阻塞 Bridge 通讯",-1),q=(0,n.Wm)("p",null,"Native 渲染：Native 侧递归解析 render tree，布局越复杂，渲染时间越长",-1),z=(0,n.Wm)("h4",{id:"_4-1-通过一定的布局技巧降低-ui-嵌套层级-降低-ui-视图的复杂度",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_4-1-通过一定的布局技巧降低-ui-嵌套层级-降低-ui-视图的复杂度","aria-hidden":"true"},"#"),(0,n.Uk)(" 4.1 通过一定的布局技巧降低 UI 嵌套层级，降低 UI 视图的复杂度")],-1),F=(0,n.Wm)("h4",{id:"_4-2-减少-re-render-直接在-js-侧截断重绘流程-减少-bridge-通讯的频率和数据量",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_4-2-减少-re-render-直接在-js-侧截断重绘流程-减少-bridge-通讯的频率和数据量","aria-hidden":"true"},"#"),(0,n.Uk)(" 4.2 减少 re-render，直接在 JS 侧截断重绘流程，减少 bridge 通讯的频率和数据量")],-1),A=(0,n.Wm)("h4",{id:"_4-3-如果是-react-native-为主架构的-app-首屏可以直接替换为-native-view-直接脱离-rn-的渲染流程",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_4-3-如果是-react-native-为主架构的-app-首屏可以直接替换为-native-view-直接脱离-rn-的渲染流程","aria-hidden":"true"},"#"),(0,n.Uk)(" 4.3 如果是 React Native 为主架构的 APP，首屏可以直接替换为 Native View，直接脱离 RN 的渲染流程")],-1),V=(0,n.Wm)("h2",{id:"rn性能优化",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#rn性能优化","aria-hidden":"true"},"#"),(0,n.Uk)(" RN性能优化")],-1),y=(0,n.Wm)("h3",{id:"_1-减少-re-render",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_1-减少-re-render","aria-hidden":"true"},"#"),(0,n.Uk)(" 1. 减少 re-render")],-1),G=(0,n.Wm)("p",null,"使用shouldComponentUpdate",-1),L=(0,n.Wm)("p",null,"React.PureComponent/React.memo React.useMemo 和 React.useCallback",-1),Y=(0,n.Wm)("h3",{id:"_2-减轻渲染压力",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_2-减轻渲染压力","aria-hidden":"true"},"#"),(0,n.Uk)(" 2. 减轻渲染压力")],-1),K=(0,n.Wm)("p",null,"使用 React.Fragment 避免多层嵌套",-1),Q=(0,n.Wm)("p",null,"减少 GPU 过度绘制 减少背景色的重复设置 避免设置半透明颜色 圆角 阴影",-1),X=(0,n.Wm)("h3",{id:"_3-动画性能优化",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#_3-动画性能优化","aria-hidden":"true"},"#"),(0,n.Uk)(" 3.动画性能优化")],-1),Z=(0,n.Wm)("h4",{id:"三个线程",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#三个线程","aria-hidden":"true"},"#"),(0,n.Uk)(" 三个线程")],-1),$=(0,n.Wm)("p",null,"UI Thread：在 iOS/Android 上专门绘制 UI 的线程",-1),ee=(0,n.Wm)("p",null,"JS Thread：我们写的业务代码基本都在这个线程上，React 重绘，处理 HTTP 请求的结果，磁盘数据 IO 等等",-1),re=(0,n.Wm)("p",null,"other Thread：泛指其他线程，比如说数据请求线程，磁盘 IO 线程等等",-1),ae=(0,n.Wm)("h4",{id:"优化方向",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#优化方向","aria-hidden":"true"},"#"),(0,n.Uk)(" 优化方向")],-1),ne=(0,n.Wm)("ol",null,[(0,n.Wm)("li",null,[(0,n.Wm)("p",null,"减少 JS Thread 和 UI Thread 之间的异步通信")]),(0,n.Wm)("li",null,[(0,n.Wm)("p",null,"尽量减少 JS Thread 侧的计算")])],-1),le=(0,n.Wm)("h4",{id:"优化方法",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#优化方法","aria-hidden":"true"},"#"),(0,n.Uk)(" 优化方法")],-1),de=(0,n.Wm)("ol",null,[(0,n.Wm)("li",null,"开启 useNativeDrive: true")],-1),ie=(0,n.Wm)("p",null,"可以预测的动画，可以使用 useNativeDrive: true 开启原生动画驱动，通过启用原生驱动，我们在启动动画前就把其所有配置信息都发送到原生端，利用原生代码在 UI 线程执行动画，而不用每一帧都在两端间来回沟通。如此一来，动画一开始就完全脱离了 JS 线程，因此此时即便 JS 线程被卡住，也不会影响到动画了。",-1),te=(0,n.Wm)("ol",{start:"2"},[(0,n.Wm)("li",null,"使用 setNativeProps")],-1),he=(0,n.Wm)("p",null,"如果把数字存在 this.state 里， 每次滑动不可避免的要进行大量的 setState，React 端会进行大量的重绘操作，可能会引起掉帧。我们这里就可以用 setNativeProps，避免 React 端重绘，相当于直接修改 DOM 上的数字，这样可以让动画更加流畅。",-1),me=(0,n.Wm)("ol",{start:"3"},[(0,n.Wm)("li",null,"使用 InteractionManager")],-1),ue=(0,n.Wm)("p",null,"原生应用感觉如此流畅的一个重要原因就是在互动和动画的过程中避免繁重的操作。 在 React Native 里，JS 线程太忙了，啥都要干，我们可以把一些繁重的任务放在 InteractionManager.runAfterInteractions() 里，确保在执行前所有的交互和动画都已经处理完毕。",-1),se=(0,n.Wm)("h3",{id:"四、长列表性能优化",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#四、长列表性能优化","aria-hidden":"true"},"#"),(0,n.Uk)(" 四、长列表性能优化")],-1),We=(0,n.Wm)("p",null,"列表配置优化",-1),ce=(0,n.Wm)("p",null,"ListItems 优化",-1),oe=(0,n.Wm)("h2",{id:"rn性能常见问题",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#rn性能常见问题","aria-hidden":"true"},"#"),(0,n.Uk)(" RN性能常见问题")],-1),pe=(0,n.Wm)("p",null,[(0,n.Wm)("img",{src:l,alt:"性能问题"})],-1),be=(0,n.Wm)("h2",{id:"rn性能优化方案",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#rn性能优化方案","aria-hidden":"true"},"#"),(0,n.Uk)(" RN性能优化方案")],-1),_e=(0,n.Wm)("p",null,[(0,n.Wm)("img",{src:d,alt:"优化方案"})],-1),ke={render:function(e,r){return(0,n.wg)(),(0,n.j4)(n.HY,null,[i,t,h,m,u,s,W,c,o,p,b,_,k,f,U,v,g,N,R,S,x,J,I,T,j,w,M,P,B,D,C,O,H,E,q,z,F,A,V,y,G,L,Y,K,Q,X,Z,$,ee,re,ae,ne,le,de,ie,te,he,me,ue,se,We,ce,oe,pe,be,_e],64)}}}}]);