(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6998],{9449:(e,a,l)=>{"use strict";l.r(a),l.d(a,{data:()=>t});const t={key:"v-4503ef2a",path:"/JavaScript/JS%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95.html",title:"JS进阶语法",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"类型判断",slug:"类型判断",children:[]},{level:2,title:"Proxy",slug:"proxy",children:[]},{level:2,title:"Reflect",slug:"reflect",children:[{level:3,title:"基本特点",slug:"基本特点",children:[]}]},{level:2,title:"WeakMap和WeakSet",slug:"weakmap和weakset",children:[]}],filePathRelative:"JavaScript/JS进阶语法.md"}},9632:(e,a,l)=>{"use strict";l.r(a),l.d(a,{default:()=>n});const t=(0,l(6252).uE)('<h1 id="js进阶语法" tabindex="-1"><a class="header-anchor" href="#js进阶语法" aria-hidden="true">#</a> JS进阶语法</h1><h2 id="类型判断" tabindex="-1"><a class="header-anchor" href="#类型判断" aria-hidden="true">#</a> 类型判断</h2><p>JS的基本类型共有七种：bigInt（bigInt是一种内置对象，是处symbol外的第二个内置类型）、number、string、boolen、symbol、undefined、null。复杂数据类型有对象（object）包括基本的对象、函数（Function）、数组（Array）和内置对象（Data等）。</p><ol><li>typeof方法</li></ol><p>基本数据类型除了null外都返回对应类型的字符串。难以判断除了函数以外的复杂数据类型。</p><ol start="2"><li>Object.prototype.toString.call方法 返回&quot;[object 类型]&quot;</li></ol><p>基本数据类型都能返回相应的类型。复杂数据类型也能返回相应的类型。这个方法可以返回内置类型</p><ol start="3"><li>obj instanceof Object</li></ol><p>只能用来判断复杂数据类型,因为instanceof 是用于检测构造函数（右边）的 prototype 属性是否出现在某个实例对象（左边）的原型链上。obj instanceof Object方法也可以判断内置对象。</p><h2 id="proxy" tabindex="-1"><a class="header-anchor" href="#proxy" aria-hidden="true">#</a> Proxy</h2><p>Proxy意思为“代理”，即在访问对象之前建立一道“拦截”，任何访问该对象的操作之前都会通过这道“拦截”，即执行Proxy里面定义的方法。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> pro <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol><li>new Proxy()表示生成一个Proxy实例</li><li>target参数表示所要拦截的目标对象</li><li>handler参数也是一个对象，用来定制拦截行为。</li></ol><h2 id="reflect" tabindex="-1"><a class="header-anchor" href="#reflect" aria-hidden="true">#</a> Reflect</h2><p>Reflect正是ES6 为了操作对象而提供的新 API。</p><h3 id="基本特点" tabindex="-1"><a class="header-anchor" href="#基本特点" aria-hidden="true">#</a> 基本特点</h3><p>只要Proxy对象具有的代理方法，Reflect对象全部具有，以静态方法的形式存在。这些方法能够执行默认行为，无论Proxy怎么修改默认行为，总是可以通过Reflect对应的方法获取默认行为。</p><p>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</p><p>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p><p>Reflect对象一共有 13 个静态方法（匹配Proxy的13种拦截行为）。</p><h2 id="weakmap和weakset" tabindex="-1"><a class="header-anchor" href="#weakmap和weakset" aria-hidden="true">#</a> WeakMap和WeakSet</h2><p>WeakSet</p><ol><li>成员都是对象；</li><li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏；</li><li>不能遍历，方法有 add、delete、has。</li></ol><p>WeakMap</p><ol><li>只接受对象最为键名（null 除外），不接受其他类型的值作为键名；</li><li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的；</li><li>不能遍历，方法有 get、set、has、delete。</li></ol>',25),n={render:function(e,a){return t}}}}]);