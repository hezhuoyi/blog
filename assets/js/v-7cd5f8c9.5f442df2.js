(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4601],{8896:(l,n,e)=>{"use strict";e.r(n),e.d(n,{data:()=>m});const m={key:"v-7cd5f8c9",path:"/Browser/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0.html",title:"从输入URL到页面呈现",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"网络篇",slug:"网络篇",children:[{level:3,title:"三次握手四次挥手及意义",slug:"三次握手四次挥手及意义",children:[]}]},{level:2,title:"解析算法篇",slug:"解析算法篇",children:[{level:3,title:"构建 DOM 树",slug:"构建-dom-树",children:[]},{level:3,title:"样式计算",slug:"样式计算",children:[]}]},{level:2,title:"渲染过程篇",slug:"渲染过程篇",children:[{level:3,title:"一、建图层树",slug:"一、建图层树",children:[]},{level:3,title:"二、生成绘制列表",slug:"二、生成绘制列表",children:[]},{level:3,title:"三、生成图块和生成位图",slug:"三、生成图块和生成位图",children:[]},{level:3,title:"四、显示器显示内容",slug:"四、显示器显示内容",children:[]}]}],filePathRelative:"Browser/从输入URL到页面呈现.md"}},6889:(l,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>Cl});var m=e(6252);const W=e.p+"assets/img/js-DNS解析.95bc94fe.png",r=e.p+"assets/img/js-网络响应.f8dc9857.png",u=e.p+"assets/img/js-样式计算.35464c89.png",s=e.p+"assets/img/js-显示器显示内容.2ccf05e8.png",a=(0,m.Wm)("h1",{id:"从输入url到页面呈现",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#从输入url到页面呈现","aria-hidden":"true"},"#"),(0,m.Uk)(" 从输入URL到页面呈现")],-1),t=(0,m.Wm)("h2",{id:"网络篇",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#网络篇","aria-hidden":"true"},"#"),(0,m.Uk)(" 网络篇")],-1),d=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"1. 构建请求--浏览器会构建请求行")],-1),i=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"2.查找强缓存")],-1),o=(0,m.Wm)("p",null,[(0,m.Uk)("当浏览器发现请求的资源已经在浏览器缓存中存有副本，"),(0,m.Wm)("strong",null,"它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载"),(0,m.Uk)("。")],-1),k=(0,m.Wm)("p",null,[(0,m.Uk)("Expires => Cache-Control 从过期时间变成过期时长 max-age就是确定缓存的时间"),(0,m.Wm)("strong",null,"秒"),(0,m.Uk)("。")],-1),c=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"3. DNS解析"),(0,m.Uk)("（淘宝京东这种网站一般使用"),(0,m.Wm)("strong",null,"DNS预解析"),(0,m.Uk)("跨过这一步，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行DNS的解析）"),(0,m.Wm)("strong",null,"（准备 IP 地址和端口）")],-1),U=(0,m.Wm)("p",null,[(0,m.Wm)("img",{src:W,alt:"DNS解析"})],-1),h=(0,m.Wm)("p",null,[(0,m.Uk)("这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，我们将这个系统就叫做"),(0,m.Wm)("strong",null,"DNS"),(0,m.Uk)("（域名系统）。得到具体 IP 的过程就是"),(0,m.Wm)("code",null,"DNS"),(0,m.Uk)("解析。浏览器提供了"),(0,m.Wm)("strong",null,"DNS数据缓存功能"),(0,m.Uk)("。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 "),(0,m.Wm)("code",null,"DNS解析"),(0,m.Uk)("。")],-1),g=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。")],-1),p=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。")],-1),b=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"路由缓存：路由器也有 DNS 缓存。")],-1),S=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"互联网服务提供商 的 DNS 服务器：ISP 有专门的 DNS 服务器应对 DNS 查询请求。")],-1),D=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）")],-1),x=(0,m.Wm)("p",null,[(0,m.Uk)("之后"),(0,m.Wm)("strong",null,"如果请求协议是 HTTPS，那么还需要建立 SSL/TLS 连接。")],-1),T=(0,m.Wm)("h5",{id:"_3-5等待-tcp-队列",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#_3-5等待-tcp-队列","aria-hidden":"true"},"#"),(0,m.Uk)(" 3.5等待 TCP 队列")],-1),C=(0,m.Wm)("p",null,[(0,m.Uk)("Chrome 有个机制，"),(0,m.Wm)("strong",null,"同一个域名同时最多只能请求 6 个 TCP 连接"),(0,m.Uk)("，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队"),(0,m.Wm)("strong",null,"等待状态"),(0,m.Uk)("，直至进行中的请求完成。如果当前请求数量少于 6 ，会直接进入下一步，建立 TCP 连接。")],-1),f=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"4.建立 TCP 连接")],-1),N=(0,m.Wm)("ol",null,[(0,m.Wm)("li",null,[(0,m.Uk)("通过"),(0,m.Wm)("strong",null,"三次握手"),(0,m.Uk)("(即总共发送3个数据包确认已经建立连接)建立客户端和服务器之间的连接。")]),(0,m.Wm)("li",null,[(0,m.Uk)("进行"),(0,m.Wm)("strong",null,"数据传输"),(0,m.Uk)("。这里有一个重要的机制，就是"),(0,m.Wm)("strong",null,[(0,m.Uk)("接收方接收到数据包后必须要向发送方"),(0,m.Wm)("code",null,"确认"),(0,m.Uk)(", 如果发送方没有接到这个"),(0,m.Wm)("code",null,"确认"),(0,m.Uk)("的消息，就判定为数据包丢失，并重新发送该数据包")]),(0,m.Uk)("。当然，发送的过程中还有一个优化策略，就是把"),(0,m.Wm)("code",null,"大的数据包拆成一个个小包"),(0,m.Uk)("，依次传输到接收方，接收方按照这个小包的顺序把它们"),(0,m.Wm)("code",null,"组装"),(0,m.Uk)("成完整数据包。")]),(0,m.Wm)("li",null,[(0,m.Uk)("断开连接的阶段。数据传输完成，现在要断开连接了，通过"),(0,m.Wm)("strong",null,"四次挥手"),(0,m.Uk)("来断开连接。")])],-1),M=(0,m.Wm)("p",null,[(0,m.Uk)("读到这里，你应该明白 TCP 连接通过什么手段来保证数据传输的可靠性，"),(0,m.Wm)("strong",null,[(0,m.Uk)("一是"),(0,m.Wm)("code",null,"三次握手"),(0,m.Uk)("确认连接，二是"),(0,m.Wm)("code",null,"数据包校验"),(0,m.Uk)("保证数据到达接收方，三是通过"),(0,m.Wm)("code",null,"四次挥手"),(0,m.Uk)("断开连接。")])],-1),v=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"5.发送 HTTP 请求")],-1),O=(0,m.Wm)("p",null,[(0,m.Uk)("浏览器发 HTTP 请求要携带三样东西:"),(0,m.Wm)("strong",null,"请求行"),(0,m.Uk)("、"),(0,m.Wm)("strong",null,"请求头"),(0,m.Uk)("和"),(0,m.Wm)("strong",null,"请求体"),(0,m.Uk)("。")],-1),P=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"6.网络响应")],-1),A=(0,m.Wm)("p",null,[(0,m.Uk)("网络响应具有三个部分:"),(0,m.Wm)("strong",null,"响应行"),(0,m.Uk)("、"),(0,m.Wm)("strong",null,"响应头"),(0,m.Uk)("和"),(0,m.Wm)("strong",null,"响应体"),(0,m.Uk)("。")],-1),I=(0,m.Wm)("p",null,[(0,m.Uk)("如果请求头或响应头中包含"),(0,m.Wm)("strong",null,"Connection: Keep-Alive"),(0,m.Uk)("，表示建立了持久连接，这样"),(0,m.Wm)("code",null,"TCP"),(0,m.Uk)("连接会一直保持，之后请求统一站点的资源会复用这个连接。")],-1),L=(0,m.Wm)("p",null,[(0,m.Uk)("否则断开"),(0,m.Wm)("code",null,"TCP"),(0,m.Uk)("连接, 请求-响应流程结束。")],-1),E=(0,m.Wm)("h3",{id:"三次握手四次挥手及意义",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#三次握手四次挥手及意义","aria-hidden":"true"},"#"),(0,m.Uk)(" 三次握手四次挥手及意义")],-1),H=(0,m.Wm)("div",{class:"language-text ext-text line-numbers-mode"},[(0,m.Wm)("pre",{class:"language-text"},[(0,m.Wm)("code",null,"建立TCP连接时，需要客户端和服务器共发送3个包。\n• 第一次：客户端发送初始序号x和syn=1请求标志\n• 第二次：服务器发送请求标志syn，发送确认标志ACK，发送自己的序号seq=y，发送客户端的确认序号ack=x+1\n• 第三次：客户端发送ACK确认号，发送自己的序号seq=x+1，发送对方的确认号ack=y+1\n\n• 第一次挥手：客户端发出释放FIN=1，自己序列号seq=u，进入FIN-WAIT-1状态\n• 第二次挥手：服务器收到客户端的后，发出ACK=1确认标志和客户端的确认号ack=u+1，自己的序列号seq=v，进入CLOSE-WAIT状态\n• 第三次挥手：客户端收到服务器确认结果后，进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己序号seq=w，服务器进入LAST-ACK（最后确认态）\n• 第四次挥手：客户端收到回复后，发送确认ACK=1，ack=w+1，自己的seq=u+1，客户端进入TIME-WAIT（时间等待）。客户端经过2个最长报文段寿命后，客户端CLOSE；服务器收到确认后，立刻进入CLOSE状态。\n\n三次握手时，服务器同时把ACK和SYN放在一起发送到了客户端那里\n四次挥手时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发送。\n")]),(0,m.Wm)("div",{class:"line-numbers"},[(0,m.Wm)("span",{class:"line-number"},"1"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"2"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"3"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"4"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"5"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"6"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"7"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"8"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"9"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"10"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"11"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"12"),(0,m.Wm)("br")])],-1),K=(0,m.Wm)("p",null,[(0,m.Wm)("img",{src:r,alt:"网络响应"})],-1),w=(0,m.Wm)("p",null,"默认情况下，Chrome 会为每个页面分配一个渲染进程。",-1),y=(0,m.Wm)("h2",{id:"解析算法篇",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#解析算法篇","aria-hidden":"true"},"#"),(0,m.Uk)(" 解析算法篇")],-1),B=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"浏览器解析：1.构建 DOM树 =>2.样式计算 =>3.生成布局树")],-1),q=(0,m.Wm)("p",null,[(0,m.Uk)("大厂网站首屏优化：将"),(0,m.Wm)("strong",null,"首屏内容静态化在html里面"),(0,m.Uk)("，直接"),(0,m.Wm)("strong",null,"解析DOM时渲染出来")],-1),F=(0,m.Wm)("p",null,[(0,m.Uk)("紧邻首屏的内容，如果不能包含在html中静态化，那么可以让在在页面渲染后，立刻执行"),(0,m.Wm)("strong",null,"异步获取数据")],-1),j=(0,m.Wm)("h3",{id:"构建-dom-树",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#构建-dom-树","aria-hidden":"true"},"#"),(0,m.Uk)(" 构建 DOM 树")],-1),R=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"输入 HTML 文件，然后经由 HTML 解析器解析，最终输出保存在内存中树状结构 DOM。")],-1),z=(0,m.Wm)("p",null,[(0,m.Uk)("由于浏览器无法直接理解"),(0,m.Wm)("code",null,"HTML字符串"),(0,m.Uk)("，因此将这一系列的"),(0,m.Wm)("strong",null,[(0,m.Uk)("字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是"),(0,m.Wm)("code",null,"DOM树")]),(0,m.Uk)("。"),(0,m.Wm)("code",null,"DOM树"),(0,m.Uk)("本质上是一个以"),(0,m.Wm)("code",null,"document"),(0,m.Uk)("为根节点的多叉树。")],-1),Y=(0,m.Wm)("div",{class:"language-text ext-text line-numbers-mode"},[(0,m.Wm)("pre",{class:"language-text"},[(0,m.Wm)("code",null,"1.先浏览器从磁盘或网络中读取 `HTML` 原始字节(0 和 1)，并根据文件的指定编码将它们转成字符。\n\n2.分词器通过词法分析将字节流转换为 `Token`，这一过程在词法分析中叫做标记化（tokenization）。\n在`Token`（也就是令牌）生成的同时，另一个流程会同时消耗这些令牌并转换成 `HTML head` 这些节点对象，起始和结束令牌表明了节点之间的关系（Node）。\n\n3.当所有的令牌消耗完以后就转换成了`DOM`（文档对象模型）。\n")]),(0,m.Wm)("div",{class:"line-numbers"},[(0,m.Wm)("span",{class:"line-number"},"1"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"2"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"3"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"4"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"5"),(0,m.Wm)("br"),(0,m.Wm)("span",{class:"line-number"},"6"),(0,m.Wm)("br")])],-1),_=(0,m.Wm)("p",null,"构建 CSSOM 树流程类似，之后渲染引擎就会构造布局树并过滤不需要显示的元素。",-1),G=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"字节数据 => 字符串 => Token => Node => DOM（CSSOM）")],-1),Q=(0,m.Wm)("h4",{id:"解析算法-1-标记化-2-建树",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#解析算法-1-标记化-2-建树","aria-hidden":"true"},"#"),(0,m.Uk)(" 解析算法 1.标记化 2.建树")],-1),J=(0,m.Wm)("h5",{id:"标记化算法",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#标记化算法","aria-hidden":"true"},"#"),(0,m.Uk)(" 标记化算法")],-1),V=(0,m.Wm)("p",null,[(0,m.Uk)("这个算法输入为"),(0,m.Wm)("code",null,"HTML文本"),(0,m.Uk)("，输出为"),(0,m.Wm)("code",null,"HTML标记"),(0,m.Uk)("，也成为"),(0,m.Wm)("strong",null,"标记生成器"),(0,m.Uk)("。其中运用"),(0,m.Wm)("strong",null,"有限自动状态机"),(0,m.Uk)("来完成。即在当当前状态下，接收一个或多个字符，就会更新到下一个状态。")],-1),X=(0,m.Wm)("h5",{id:"建树算法",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#建树算法","aria-hidden":"true"},"#"),(0,m.Uk)(" 建树算法")],-1),Z=(0,m.Wm)("p",null,[(0,m.Uk)("之前提到过，DOM 树是一个以"),(0,m.Wm)("code",null,"document"),(0,m.Uk)("为根节点的多叉树。因此解析器首先会创建一个"),(0,m.Wm)("code",null,"document"),(0,m.Uk)("对象。标记生成器会把每个标记的信息发送给"),(0,m.Wm)("strong",null,"建树器"),(0,m.Uk)("。"),(0,m.Wm)("strong",null,"建树器"),(0,m.Uk)("接收到相应的标记时，会"),(0,m.Wm)("strong",null,"创建对应的 DOM 对象"),(0,m.Uk)("。创建这个"),(0,m.Wm)("code",null,"DOM对象"),(0,m.Uk)("后会做两件事情:")],-1),$=(0,m.Wm)("ol",null,[(0,m.Wm)("li",null,[(0,m.Uk)("将"),(0,m.Wm)("code",null,"DOM对象"),(0,m.Uk)("加入 DOM 树中。")]),(0,m.Wm)("li",null,[(0,m.Uk)("将对应标记压入存放开放(与"),(0,m.Wm)("code",null,"闭合标签"),(0,m.Uk)("意思对应)元素的栈中。")])],-1),ll=(0,m.Wm)("h3",{id:"样式计算",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#样式计算","aria-hidden":"true"},"#"),(0,m.Uk)(" 样式计算")],-1),nl=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"3种来源：link标签引用 style标签中的样式 元素的内嵌style属性")],-1),el=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"格式化样式表（document.styleSheets） => 标准化样式属性 比如：blue->rgb(0,0,255) => 计算每个节点的具体样式 => 生成布局树")],-1),ml=(0,m.Wm)("p",null,[(0,m.Wm)("img",{src:u,alt:"样式计算"})],-1),Wl=(0,m.Wm)("h2",{id:"渲染过程篇",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#渲染过程篇","aria-hidden":"true"},"#"),(0,m.Uk)(" 渲染过程篇")],-1),rl=(0,m.Wm)("ul",null,[(0,m.Wm)("li",null,[(0,m.Wm)("strong",null,"1.建立图层树")]),(0,m.Wm)("li",null,[(0,m.Wm)("strong",null,"2.生成绘制列表"),(0,m.Uk)(" -- 渲染引擎")]),(0,m.Wm)("li",null,[(0,m.Uk)("3.绘制："),(0,m.Wm)("strong",null,"生成图块和生成位图并栅格化"),(0,m.Uk)(" -- 渲染引擎中的合成线程")]),(0,m.Wm)("li",null,[(0,m.Wm)("strong",null,"4.显示器显示内容")])],-1),ul=(0,m.Wm)("h3",{id:"一、建图层树",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#一、建图层树","aria-hidden":"true"},"#"),(0,m.Uk)(" 一、建图层树")],-1),sl=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。"),(0,m.Uk)("(两种方式)")],-1),al=(0,m.Wm)("p",null,"通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。",-1),tl=(0,m.Wm)("h4",{id:"显示合成",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#显示合成","aria-hidden":"true"},"#"),(0,m.Uk)(" 显示合成")],-1),dl=(0,m.Wm)("p",null,[(0,m.Uk)("一、 拥有"),(0,m.Wm)("strong",null,"层叠上下文属性的元素"),(0,m.Uk)("的节点。")],-1),il=(0,m.Wm)("p",null,[(0,m.Uk)("二、需要"),(0,m.Wm)("strong",null,"剪裁"),(0,m.Uk)("的地方。")],-1),ol=(0,m.Wm)("h4",{id:"隐式合成",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#隐式合成","aria-hidden":"true"},"#"),(0,m.Uk)(" 隐式合成")],-1),kl=(0,m.Wm)("p",null,[(0,m.Uk)("简单来说就是"),(0,m.Wm)("code",null,"层叠等级低"),(0,m.Uk)("的节点被提升为单独的图层之后，那么"),(0,m.Wm)("code",null,"所有层叠等级比它高"),(0,m.Uk)("的节点"),(0,m.Wm)("strong",null,"都会"),(0,m.Uk)("成为一个单独的图层。可能发生层爆炸。")],-1),cl=(0,m.Wm)("h3",{id:"二、生成绘制列表",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#二、生成绘制列表","aria-hidden":"true"},"#"),(0,m.Uk)(" 二、生成绘制列表")],-1),Ul=(0,m.Wm)("p",null,[(0,m.Wm)("strong",null,"渲染引擎"),(0,m.Uk)("会将"),(0,m.Wm)("strong",null,"图层的绘制拆分成一个个绘制指令"),(0,m.Uk)("，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。")],-1),hl=(0,m.Wm)("h3",{id:"三、生成图块和生成位图",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#三、生成图块和生成位图","aria-hidden":"true"},"#"),(0,m.Uk)(" 三、生成图块和生成位图")],-1),gl=(0,m.Wm)("p",null,[(0,m.Uk)("绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上"),(0,m.Wm)("strong",null,"绘制操作是由渲染引擎中的合成线程"),(0,m.Uk)("来完成的。")],-1),pl=(0,m.Wm)("p",null,[(0,m.Uk)("当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程，"),(0,m.Wm)("strong",null,"合成线程会将图层划分为图块"),(0,m.Uk)("，然后合成线程会"),(0,m.Wm)("strong",null,"按照视口附近的图块来优先生成位图"),(0,m.Uk)("，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。"),(0,m.Wm)("strong",null,"渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。")],-1),bl=(0,m.Wm)("p",null,[(0,m.Uk)("生成位图的过程实际上都会使用 "),(0,m.Wm)("strong",null,"GPU 进行加速"),(0,m.Uk)("，"),(0,m.Wm)("strong",null,"生成的位图最后发送给合成线程"),(0,m.Uk)("。")],-1),Sl=(0,m.Wm)("h3",{id:"四、显示器显示内容",tabindex:"-1"},[(0,m.Wm)("a",{class:"header-anchor",href:"#四、显示器显示内容","aria-hidden":"true"},"#"),(0,m.Uk)(" 四、显示器显示内容")],-1),Dl=(0,m.Wm)("p",null,[(0,m.Uk)("栅格化操作完成后，"),(0,m.Wm)("strong",null,"合成线程"),(0,m.Uk)('会生成一个绘制命令，即"DrawQuad"，并发送给浏览器进程。')],-1),xl=(0,m.Wm)("p",null,[(0,m.Uk)("浏览器进程中的"),(0,m.Wm)("code",null,"viz组件"),(0,m.Uk)("接收到这个命令，根据这个命令，把"),(0,m.Wm)("strong",null,"页面内容绘制到内存"),(0,m.Uk)("，最后再将内存显示在"),(0,m.Wm)("strong",null,"屏幕"),(0,m.Uk)("上。")],-1),Tl=(0,m.Wm)("p",null,[(0,m.Wm)("img",{src:s,alt:"显示器显示内容"})],-1),Cl={render:function(l,n){return(0,m.wg)(),(0,m.j4)(m.HY,null,[a,t,d,i,o,k,c,U,h,g,p,b,S,D,x,T,C,f,N,M,v,O,P,A,I,L,E,H,K,w,y,B,q,F,j,R,z,Y,_,G,Q,J,V,X,Z,$,ll,nl,el,ml,Wl,rl,ul,sl,al,tl,dl,il,ol,kl,cl,Ul,hl,gl,pl,bl,Sl,Dl,xl,Tl],64)}}}}]);