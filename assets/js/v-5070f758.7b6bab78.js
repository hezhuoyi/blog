(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7363],{8589:(n,s,a)=>{"use strict";a.r(s),a.d(s,{data:()=>p});const p={key:"v-5070f758",path:"/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96.html",title:"模块化",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"服务端模块化",slug:"服务端模块化",children:[{level:3,title:"Nodejs和CommonJS的关系",slug:"nodejs和commonjs的关系",children:[]},{level:3,title:"CommonJS规范简介",slug:"commonjs规范简介",children:[]},{level:3,title:"Nodejs的模块化实现",slug:"nodejs的模块化实现",children:[]},{level:3,title:"Node模块分类",slug:"node模块分类",children:[]}]},{level:2,title:"前端模块化",slug:"前端模块化",children:[{level:3,title:"前端模块化和服务端模块化有什么区别",slug:"前端模块化和服务端模块化有什么区别",children:[]},{level:3,title:"为什么CommonJS不适用于前端模块",slug:"为什么commonjs不适用于前端模块",children:[]},{level:3,title:"AMD(Asynchronous Module Definition) & RequireJS",slug:"amd-asynchronous-module-definition-requirejs",children:[]},{level:3,title:"CommonJS 和AMD的对比：",slug:"commonjs-和amd的对比",children:[]},{level:3,title:"什么是运行时加载",slug:"什么是运行时加载",children:[]},{level:3,title:"CMD(Common Module Definition) & SeaJS",slug:"cmd-common-module-definition-seajs",children:[]},{level:3,title:"UMD(Universal Module Definition) 通用模块规范",slug:"umd-universal-module-definition-通用模块规范",children:[]},{level:3,title:"ES6模块",slug:"es6模块",children:[]},{level:3,title:"ES6模块与CommonJS模块加载区别",slug:"es6模块与commonjs模块加载区别",children:[]}]}],filePathRelative:"JavaScript/模块化.md"}},3189:(n,s,a)=>{"use strict";a.r(s),a.d(s,{default:()=>e});const p=(0,a(6252).uE)('<h1 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h1><p>模块化是一种思想, 是将大工程拆成小的模块分治的思想.</p><h2 id="服务端模块化" tabindex="-1"><a class="header-anchor" href="#服务端模块化" aria-hidden="true">#</a> 服务端模块化</h2><h3 id="nodejs和commonjs的关系" tabindex="-1"><a class="header-anchor" href="#nodejs和commonjs的关系" aria-hidden="true">#</a> Nodejs和CommonJS的关系</h3><p>这里要说一下Nodejs和CommonJS的关系。</p><ol><li>Nodejs的模块化能一种成熟的姿态出现离不开CommonJS的规范的影响</li><li>在服务器端CommonJS能以一种寻常的姿态写进各个公司的项目代码中，离不开Node的优异表现</li><li>Node并非完全按照规范实现，针对模块规范进行了一定的取舍，同时也增加了少许自身特性</li></ol><h3 id="commonjs规范简介" tabindex="-1"><a class="header-anchor" href="#commonjs规范简介" aria-hidden="true">#</a> CommonJS规范简介</h3><p>CommonJS对模块的定义非常简单，主要分为模块引用，模块定义和模块标识(require()函数)3部分</p><p>意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出将上下游模块无缝衔接，每个模块具有独立的空间，它们互不干扰。</p><h3 id="nodejs的模块化实现" tabindex="-1"><a class="header-anchor" href="#nodejs的模块化实现" aria-hidden="true">#</a> Nodejs的模块化实现</h3><p>Node模块在实现中并非完全按照CommonJS来，进行了取舍，增加了一些自身的的特性。</p><p>Node中一个文件是一个模块——module</p><p>一个模块就是一个Module的实例</p><h3 id="node模块分类" tabindex="-1"><a class="header-anchor" href="#node模块分类" aria-hidden="true">#</a> Node模块分类</h3><p>Node模块一般分为两种核心模块和文件模块。</p><p><strong>核心模块——就是Node内置的模块比如http， path等。在Node的源码的编译时，核心模块就一起被编译进了二进制执行文件，部分核心模块(内建模块)被直接加载进内存中。</strong></p><p>在Node模块的引入过程中，一般要经过一下三个步骤</p><ol><li>路径分析 2. 文件定位 3. 编译执行</li></ol><p>核心模块会省略文件定位和编译执行这两步，并且在路径分析中会优先判断，加载速度比一般模块更快。</p><p>文件模块——就是外部引入的模块如node_modules里通过npm安装的模块，或者我们项目工程里自己写的一个js文件或者json文件。</p><p>文件模块引入过程以上三个步骤都要经历。</p><h2 id="前端模块化" tabindex="-1"><a class="header-anchor" href="#前端模块化" aria-hidden="true">#</a> 前端模块化</h2><h3 id="前端模块化和服务端模块化有什么区别" tabindex="-1"><a class="header-anchor" href="#前端模块化和服务端模块化有什么区别" aria-hidden="true">#</a> 前端模块化和服务端模块化有什么区别</h3><p>服务端加载一个模块，直接就从硬盘或者内存中读取了，消耗时间可以忽略不计 浏览器需要从服务端下载这个文件，所以说如果用CommonJS的require方式加载模块，需要等代码模块下载完毕，并运行之后才能得到所需要的API。</p><h3 id="为什么commonjs不适用于前端模块" tabindex="-1"><a class="header-anchor" href="#为什么commonjs不适用于前端模块" aria-hidden="true">#</a> 为什么CommonJS不适用于前端模块</h3><p>如果我们在某个代码模块里使用CommonJS的方法require了一个模块，而这个模块需要通过http请求从服务器去取，如果网速很慢，而CommonJS又是同步的，所以将阻塞后面代码的执行，从而阻塞浏览器渲染页面，使得页面出现假死状态。</p><p>因此后面AMD规范随着RequireJS的推广被提出，异步模块加载，不阻塞后面代码执行的模块引入方式，就是解决了前端模块异步模块加载的问题。</p><h3 id="amd-asynchronous-module-definition-requirejs" tabindex="-1"><a class="header-anchor" href="#amd-asynchronous-module-definition-requirejs" aria-hidden="true">#</a> AMD(Asynchronous Module Definition) &amp; RequireJS</h3><p>AMD——异步模块加载规范 与CommonJS的主要区别就是<strong>异步模块加载</strong>，就是模块加载过程中即使require的模块还没有获取到，也不会影响后面代码的执行。</p><p>RequireJS——AMD规范的实现。其实也可以说AMD是RequireJS在推广过程中对模块定义的规范化产出。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">//a.js</span>\n<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;a.js执行&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">hello</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hello, a.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">//b.js</span>\n<span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;b.js 执行&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  a<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&#39;#b&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    b<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="commonjs-和amd的对比" tabindex="-1"><a class="header-anchor" href="#commonjs-和amd的对比" aria-hidden="true">#</a> CommonJS 和AMD的对比：</h3><p>CommonJS一般用于服务端，AMD一般用于浏览器客户端</p><p>CommonJS和AMD都是运行时加载</p><h3 id="什么是运行时加载" tabindex="-1"><a class="header-anchor" href="#什么是运行时加载" aria-hidden="true">#</a> 什么是运行时加载</h3><p>CommonJS 和AMD模块都只能在运行时确定模块之间的依赖关系</p><p>require一个模块的时候，模块会先被执行，并返回一个对象，并且这个对象是整体加载的</p><h3 id="cmd-common-module-definition-seajs" tabindex="-1"><a class="header-anchor" href="#cmd-common-module-definition-seajs" aria-hidden="true">#</a> CMD(Common Module Definition) &amp; SeaJS</h3><p>CMD——通用模块规范，由国内的玉伯提出。</p><p>SeaJS——CMD的实现，其实也可以说CMD是SeaJS在推广过程中对模块定义的规范化产出。</p><p>与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;dep1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;dep2&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">dep1<span class="token punctuation">,</span> dep2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token comment">//依赖模块a</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./a&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">//调用模块a的方法</span>\n  a<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在依赖示例部分，CMD支持动态引入，require、exports和module通过形参传递给模块，在需要依赖模块时，随时调用require( )引入即可，</p><p><strong>也就是说与AMD相比，CMD推崇依赖就近， AMD推崇依赖前置。</strong></p><h3 id="umd-universal-module-definition-通用模块规范" tabindex="-1"><a class="header-anchor" href="#umd-universal-module-definition-通用模块规范" aria-hidden="true">#</a> UMD(Universal Module Definition) 通用模块规范</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">global<span class="token punctuation">,</span> factory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">typeof</span> exports <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> module <span class="token operator">!==</span> <span class="token string">&#39;undefined&#39;</span> \n       <span class="token operator">?</span> module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment">// Node , CommonJS</span>\n       <span class="token operator">:</span> <span class="token keyword">typeof</span> define <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span> <span class="token operator">&amp;&amp;</span> define<span class="token punctuation">.</span>amd  \n         <span class="token operator">?</span> <span class="token function">define</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span>                   <span class="token comment">//AMD CMD</span>\n         <span class="token operator">:</span> <span class="token punctuation">(</span>global<span class="token punctuation">.</span>CodeMirror <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//模块挂载到全局</span>\n<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n   <span class="token operator">...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可以看说所谓的兼容模式是将几种常见模块定义方式都兼容处理。</p><h3 id="es6模块" tabindex="-1"><a class="header-anchor" href="#es6模块" aria-hidden="true">#</a> ES6模块</h3><p>CommonJS和AMD都是运行时加载。ES6在语言规格层面上实现了模块功能，是编译时加载，完全可以取代现有的CommonJS和AMD规范，可以成为浏览器和服务器通用的模块解决方案。</p><h3 id="es6模块与commonjs模块加载区别" tabindex="-1"><a class="header-anchor" href="#es6模块与commonjs模块加载区别" aria-hidden="true">#</a> ES6模块与CommonJS模块加载区别</h3><p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。所以说ES6是编译时加载，不同于CommonJS的运行时加载(实际加载的是一整个对象)，ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">//ES6模块</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> basename<span class="token punctuation">,</span> dirname<span class="token punctuation">,</span> parse <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;path&#39;</span><span class="token punctuation">;</span>\n\n<span class="token comment">//CommonJS模块</span>\n<span class="token keyword">let</span> <span class="token punctuation">{</span> basename<span class="token punctuation">,</span> dirname<span class="token punctuation">,</span> parse <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;path&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>以上这种写法与CommonJS的模块加载有什么不同？</p><ol><li><p>当require path模块时，其实 CommonJS会将path模块运行一遍，并返回一个对象，并将这个对象缓存起来，这个对象包含path这个模块的所有API。以后无论多少次加载这个模块都是取这个缓存的值，也就是第一次运行的结果，除非手动清除。</p></li><li><p>ES6会从path模块只加载3个方法，其他不会加载，这就是编译时加载。ES6可以在编译时就完成模块加载，当ES6遇到import时，不会像CommonJS一样去执行模块，而是生成一个动态的只读引用，当真正需要的时候再到模块里去取值，所以ES6模块是动态引用，并且不会缓存值。</p></li></ol><p>因为CommonJS模块输出的是值的拷贝，所以当模块内值变化时，不会影响到输出的值。</p>',55),e={render:function(n,s){return p}}}}]);