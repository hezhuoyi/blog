(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2914],{946:(e,a,l)=>{"use strict";l.r(a),l.d(a,{data:()=>r});const r={key:"v-41b7359e",path:"/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85.html",title:"作用域和闭包",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"js 执行上下文",slug:"js-执行上下文",children:[]},{level:2,title:"词法作用域（Lexical scope）",slug:"词法作用域-lexical-scope",children:[]},{level:2,title:"闭包",slug:"闭包",children:[]}],filePathRelative:"JavaScript/作用域和闭包.md"}},5763:(e,a,l)=>{"use strict";l.r(a),l.d(a,{default:()=>c});var r=l(6252);const i=(0,r.uE)('<h1 id="作用域和闭包" tabindex="-1"><a class="header-anchor" href="#作用域和闭包" aria-hidden="true">#</a> 作用域和闭包</h1><h2 id="js-执行上下文" tabindex="-1"><a class="header-anchor" href="#js-执行上下文" aria-hidden="true">#</a> js 执行上下文</h2><p>当我们启动程序时，我们从全局执行上下文中开始。</p><p>一些变量是在全局执行上下文中声明的。我们称之为全局变量。</p><p>当程序调用一个函数时发生以下几个步骤：</p><ol><li>JavaScript创建一个新的执行上下文，我们叫作本地执行上下文。</li><li>这个本地执行上下文将有它自己的一组变量，这些变量将是这个执行上下文的本地变量。</li><li>新的执行上下文被推到到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。</li></ol><h2 id="词法作用域-lexical-scope" tabindex="-1"><a class="header-anchor" href="#词法作用域-lexical-scope" aria-hidden="true">#</a> 词法作用域（Lexical scope）</h2><p>JavaScript的一个复杂之处在于它如何查找变量，如果在函数执行上下文中找不到变量，它将在调用上下文中寻找它，如果在它的调用上下文中没有找到，就一直往上一级，直到它在全局执行上下文中查找为止。(如果最后找不到，它就是 undefined)。</p><p>一个函数可以访问在它的调用上下文中定义的变量，这个就是词法作用域（Lexical scope）。</p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><p>它是这样工作的，无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。</p><p>我将永远记住闭包的方法是通过背包的类比。当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量。</p>',12),t={href:"https://zhuanlan.zhihu.com/p/366658450",target:"_blank",rel:"noopener noreferrer"},h=(0,r.Uk)("JavaScript 的静态作用域链与“动态”闭包链"),c={render:function(e,a){const l=(0,r.up)("OutboundLink");return(0,r.wg)(),(0,r.j4)(r.HY,null,[i,(0,r.Wm)("p",null,[(0,r.Wm)("a",t,[h,(0,r.Wm)(l)])])],64)}}}}]);