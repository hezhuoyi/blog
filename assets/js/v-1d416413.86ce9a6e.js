(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5307],{4121:(e,l,a)=>{"use strict";a.r(l),a.d(l,{data:()=>r});const r={key:"v-1d416413",path:"/Framework/RN/%E6%96%B0%E6%9E%B6%E6%9E%84.html",title:"新架构",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"旧模式",slug:"旧模式",children:[]},{level:2,title:"Bridge的问题",slug:"bridge的问题",children:[]},{level:2,title:"新架构",slug:"新架构-1",children:[{level:3,title:"JSI",slug:"jsi",children:[]},{level:3,title:"Fabric",slug:"fabric",children:[]},{level:3,title:"TurboModules",slug:"turbomodules",children:[]},{level:3,title:"CodeGen",slug:"codegen",children:[]},{level:3,title:"Lean Core",slug:"lean-core",children:[]}]}],filePathRelative:"Framework/RN/新架构.md"}},4543:(e,l,a)=>{"use strict";a.r(l),a.d(l,{default:()=>q});var r=a(6252);const d=a.p+"assets/img/rn-old.c7e82c1b.jpeg",i=a.p+"assets/img/rn-new.548e02aa.jpeg",n=(0,r.Wm)("h1",{id:"新架构",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#新架构","aria-hidden":"true"},"#"),(0,r.Uk)(" 新架构")],-1),t=(0,r.Wm)("h2",{id:"旧模式",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#旧模式","aria-hidden":"true"},"#"),(0,r.Uk)(" 旧模式")],-1),u=(0,r.Wm)("p",null,[(0,r.Wm)("img",{src:d,alt:"旧模式"})],-1),h=(0,r.Wm)("p",null,"RN现在主要有3个线程：",-1),m=(0,r.Wm)("ol",null,[(0,r.Wm)("li",null,"JS thread。JS代码执行线程，负责逻辑层面的处理。Metro（打包工具）将React源码打包成一个单一JS文件(就是图中JSBundle)。然后传给JS引擎执行，现在ios和android统一用的是JSC。"),(0,r.Wm)("li",null,"UI Thread(Main Thread/Native thread)。这个线程主要负责原生渲染（Native UI）和调用原生能力(Native Modules)比如蓝牙等。"),(0,r.Wm)("li",null,"Shadow Thread。 这个线程主要是创建Shadow Tree来模拟React结构树。Shadow Tree可以类似虚拟dom。RN使用Flexbox布局，但是原生是不支持，所以Yoga就是用来将Flexbox布局转换为原生平台的布局方式。")],-1),o=(0,r.Wm)("h2",{id:"bridge的问题",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#bridge的问题","aria-hidden":"true"},"#"),(0,r.Uk)(" Bridge的问题")],-1),s=(0,r.Wm)("p",null,"JS thread会先对RN布局组件序列化，通过Bridge发到ShadowThread。Shadow Tread接收到这条信息后，先反序列化，形成Shadow tree，然后传给Yoga，形成原生布局信息。",-1),c=(0,r.Wm)("p",null,"接着又通过Bridge传给UI thread。UI thread 拿到消息后，同样先反序列化，然后根据所给布局信息，进行绘制。",-1),W=(0,r.Wm)("p",null,"从上面过程可以看到三个线程的交互都是要通过Bridge，因此瓶颈也就在此。",-1),S=(0,r.Wm)("p",null,"Bridge三个特点：",-1),b=(0,r.Wm)("ol",null,[(0,r.Wm)("li",null,"异步。这些消息队列是异步的，无法保证处理事件。"),(0,r.Wm)("li",null,"序列化。通过JSON格式来传递消息，每次都要经历序列化和反序列化，开销很大。"),(0,r.Wm)("li",null,"批处理。对Native调用进行排队，批量处理。")],-1),g=(0,r.Wm)("p",null,"异步设计的好处是不阻塞，这种设计在大部分情况下性能满足需求，但是在某些情况下就会出问题，比如瀑布流滚动。",-1),p=(0,r.Wm)("p",null,"当瀑布流向下滑动的时候，需要发请求给服务端拿数据进行下一步渲染。",-1),J=(0,r.Wm)("p",null,"滚动事件发生在UI thread，然后通过Bridge发给JS thread。JS thread 监听到消息后发请求，服务端返回数据，再通过Bridge返回给Native进行渲染。由于都是异步，就会出现空白模块，导致性能问题。",-1),v=(0,r.Wm)("p",null,"从上面可以看出，性能瓶颈主要是存在JS线程和Native有交互的情况，如果不存在交互，RN的性能良好。",-1),N=(0,r.Wm)("p",null,"因此，对于RN的优化，主要集中在Bridge上，有下面3个原则：",-1),f=(0,r.Wm)("ol",null,[(0,r.Wm)("li",null,"JS和Native端不通信。最彻底的方式，消息不走Bridge。"),(0,r.Wm)("li",null,"JS和Native减少通信。在两端无法避免的情况下，尽量通信减少次数。比如多个请求合并成一个。"),(0,r.Wm)("li",null,"较少JSON的大小。比如图片转为Base64会导致传输数据变大，用网络图片代替。")],-1),I=(0,r.Wm)("h2",{id:"新架构-1",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#新架构-1","aria-hidden":"true"},"#"),(0,r.Uk)(" 新架构")],-1),B=(0,r.Wm)("p",null,"FB团队逐渐意识到了这些问题，同时也受到Flutter的压力，在2018年提出了新架构，主要有JSI、Fabric、TurboModules、CodeGen、LeanCode组成。",-1),k=(0,r.Wm)("p",null,[(0,r.Wm)("img",{src:i,alt:"新架构"})],-1),C=(0,r.Wm)("h3",{id:"jsi",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#jsi","aria-hidden":"true"},"#"),(0,r.Uk)(" JSI")],-1),U=(0,r.Wm)("p",null,"JSI是整个架构的核心和基石，所有的一切都是建立在它上面。",-1),w=(0,r.Wm)("p",null,"JSI是Javascript Interface的缩写，一个用C++写成的轻量级框架，它作用就是通过JSI，JS对象可以直接获得C++对象(Host Objects)引用，并调用对应方法。",-1),R=(0,r.Wm)("p",null,"另外JSI与React无关，可以用在任何JS 引擎（V8,Hermes)。",-1),x=(0,r.Wm)("p",null,"有了JSI，JS和Native就可以直接通信了,调用过程如下：",-1),T=(0,r.Wm)("p",null,"JS->JSI->C++->ObjectC/Java",-1),F=(0,r.Wm)("p",null,"自此三个线程通信再也不需要通过Bridge，可以直接知道对方的存在，让同步通信成为现实。具体的用法可以看 官方例子。",-1),M=(0,r.Wm)("p",null,"另外一个好处就是有了JSI，JS引擎不再局限于JSC，可以自由的替换为V8,Hermes，进一步提高JS解析执行的速度。",-1),j=(0,r.Wm)("h3",{id:"fabric",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#fabric","aria-hidden":"true"},"#"),(0,r.Uk)(" Fabric")],-1),E=(0,r.Wm)("p",null,"Fabric是整个架构中的新UI层，包括了新架构图中的renderer和shadow thread。",-1),G=(0,r.Wm)("p",null,"三个线程通过Bridge异步通信，数据需要拷贝多份。",-1),H=(0,r.Wm)("p",null,"有了JSI以后，JS可以直接掉调用其他线程，实现同步通信机制。另外数据可以直接引用，不需要拷贝。",-1),O=(0,r.Wm)("p",null,"除了同步能力，直接引用，另外一个好处是Fabric现在支持渲染优先级比如React的Concurrent和Suspense模式。",-1),y=(0,r.Wm)("h3",{id:"turbomodules",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#turbomodules","aria-hidden":"true"},"#"),(0,r.Uk)(" TurboModules")],-1),L=(0,r.Wm)("p",null,"TurboModules主要和原生应用能力相关，对应新架构图上的Native Modules，这部分的优化是：",-1),Y=(0,r.Wm)("ol",null,[(0,r.Wm)("li",null,"通过JSI，可以让JS直接调用Native模块，实现一些同步操作。比如调用摄像头能力。"),(0,r.Wm)("li",null,"Native模块懒加载。之前RN框架启动的时候会加载所有Native模块，导致启动慢，时间久。现在有了TurboModules后，可以实现按需加载，减少启动时间，提高性能。")],-1),V=(0,r.Wm)("h3",{id:"codegen",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#codegen","aria-hidden":"true"},"#"),(0,r.Uk)(" CodeGen")],-1),z=(0,r.Wm)("p",null,"通过CodeGen，自动将Flow或者Ts等有静态类型的JS代码翻译成Fabric和TurboModules使用的原生代码。",-1),A=(0,r.Wm)("h3",{id:"lean-core",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#lean-core","aria-hidden":"true"},"#"),(0,r.Uk)(" Lean Core")],-1),P=(0,r.Wm)("p",null,"这部分主要是包的瘦身，以前所有的包都放在RN核心工程里面。现在RN核心只保留必要的包，其他都移到react-native-community 或者拆出单独的组件，比如Webview和AsyncStore。",-1),q={render:function(e,l){return(0,r.wg)(),(0,r.j4)(r.HY,null,[n,t,u,h,m,o,s,c,W,S,b,g,p,J,v,N,f,I,B,k,C,U,w,R,x,T,F,M,j,E,G,H,O,y,L,Y,V,z,A,P],64)}}}}]);