(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5221],{7409:(e,a,t)=>{"use strict";t.r(a),t.d(a,{data:()=>s});const s={key:"v-8015eece",path:"/Framework/Vue/Vue3%E7%9A%84%E4%BC%98%E5%8C%96.html",title:"Vue3的优化",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"编译方面",slug:"编译方面",children:[{level:3,title:"diff方法优化",slug:"diff方法优化",children:[]},{level:3,title:"hoistStatic 静态提升",slug:"hoiststatic-静态提升",children:[]},{level:3,title:"cacheHandlers 事件侦听器缓存",slug:"cachehandlers-事件侦听器缓存",children:[]}]},{level:2,title:"变化侦测",slug:"变化侦测",children:[]},{level:2,title:"全局API分块（Tree Shake机制）",slug:"全局api分块-tree-shake机制",children:[{level:3,title:"关于 Tree Shaking",slug:"关于-tree-shaking",children:[]}]},{level:2,title:"更好的 TypeScript 支持",slug:"更好的-typescript-支持",children:[]},{level:2,title:"Composition API",slug:"composition-api",children:[]}],filePathRelative:"Framework/Vue/Vue3的优化.md"}},3852:(e,a,t)=>{"use strict";t.r(a),t.d(a,{default:()=>n});const s=(0,t(6252).uE)('<h1 id="vue3的优化" tabindex="-1"><a class="header-anchor" href="#vue3的优化" aria-hidden="true">#</a> Vue3的优化</h1><h2 id="编译方面" tabindex="-1"><a class="header-anchor" href="#编译方面" aria-hidden="true">#</a> 编译方面</h2><h3 id="diff方法优化" tabindex="-1"><a class="header-anchor" href="#diff方法优化" aria-hidden="true">#</a> diff方法优化</h3><p>Vue3对于不参与更新的元素，做静态标记并提示，只会被创建一次，在渲染时直接复用。</p><p>vue2中的虚拟dom通过模板创建虚拟节点（js对象），然后使用虚拟节点跟上一次缓存的虚拟节点进行全量的对比。在vue3中做出了改进，在与上次虚拟节点进行对比时候，只对比带有patch flag的节点，并且可以通过flag的信息得知当前节点要对比的具体内容。</p><h3 id="hoiststatic-静态提升" tabindex="-1"><a class="header-anchor" href="#hoiststatic-静态提升" aria-hidden="true">#</a> hoistStatic 静态提升</h3><p>把静态的节点进行提升，所有的静态节点都被拿到了渲染函数体外面，也就是说在应用第一次的启动被创建了一次后，之后这些虚拟节点会在每次渲染时候被不停的复用，这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用。</p><h3 id="cachehandlers-事件侦听器缓存" tabindex="-1"><a class="header-anchor" href="#cachehandlers-事件侦听器缓存" aria-hidden="true">#</a> cacheHandlers 事件侦听器缓存</h3><p>在第一次渲染时会自动生成一个内联的函数，在内联函数里面引用当前的fn，然后把内联函数cache起来，后续的更新会从缓存中读同一个函数，因为是同一个函数，也就没有追踪变化的必要，这样就神奇的把这个span变成了静态的。手写的内联函数也会被cache起来，这样就会避免一些没必要的更新。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>span onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="变化侦测" tabindex="-1"><a class="header-anchor" href="#变化侦测" aria-hidden="true">#</a> 变化侦测</h2><p>在vue2中实现数据双向绑定，是通过Object.definePropertyd劫持各个属性的getter、setter，在读取数据时触发getter，修改数据时候触发setter。</p><p>在vue3中改为用Proxy，但是Proxy只能代理一层，对于深层的无法代理。vue3中利用每次set被拦截之前都会拦截到get操作，所以vue3在get中直接对数据进行reactive，这样就大大减少了递归reactive带来的性能消耗。</p><h2 id="全局api分块-tree-shake机制" tabindex="-1"><a class="header-anchor" href="#全局api分块-tree-shake机制" aria-hidden="true">#</a> 全局API分块（Tree Shake机制）</h2><p>Vue 3源代码将加入tree-shake。这意味着，如果您不使用其某些功能（例如component或者v-show指令），它们将不会包含在您的基础包中。</p><h3 id="关于-tree-shaking" tabindex="-1"><a class="header-anchor" href="#关于-tree-shaking" aria-hidden="true">#</a> 关于 Tree Shaking</h3><p>Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination</p><p>原理：</p><ol><li>ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块</li><li>静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ol><h2 id="更好的-typescript-支持" tabindex="-1"><a class="header-anchor" href="#更好的-typescript-支持" aria-hidden="true">#</a> 更好的 TypeScript 支持</h2><p>Vue 3是用TypeScript编写的库，可以享受到自动的类型定义提示</p><h2 id="composition-api" tabindex="-1"><a class="header-anchor" href="#composition-api" aria-hidden="true">#</a> Composition API</h2><p>它以 setup 启动函数作为逻辑组织的入口，暴露了响应式 API 为用户所用，也提供了生命周期函数以及依赖注入的接口，就是将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去。</p><p><strong>Composition API响应式的实现依靠一个保存有依赖与更新对应关系的WeakMap数据结构。这里的WeakMap数据结构指的就是ES6提供的WeakMap数据结构。</strong></p><p>依赖就是reactive/ref返回的对象。而computed/watch等都通过一个函数参数消费依赖，这些函数参数就是所谓的更新。Composition API把依赖作为key，更新函数作为value来构建WeakMap，在依赖有变更时在WeakMap中找到对应的更新函数来执行，以此实现响应式。</p>',25),n={render:function(e,a){return s}}}}]);