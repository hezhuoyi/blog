(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9696],{2053:(l,n,e)=>{"use strict";e.r(n),e.d(n,{data:()=>a});const a={key:"v-b990ca88",path:"/Engineering/Webpack%E7%9B%B8%E5%85%B3.html",title:"Webpack相关",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"webpack工作流程",slug:"webpack工作流程",children:[]},{level:2,title:"Loader和Plugin的区别",slug:"loader和plugin的区别",children:[{level:3,title:"在webpack的plugin运行的过程中存在两个非常重要的对象：compiler和compilation。",slug:"在webpack的plugin运行的过程中存在两个非常重要的对象-compiler和compilation。",children:[]}]},{level:2,title:"构建流程",slug:"构建流程",children:[]},{level:2,title:"提高效率的插件",slug:"提高效率的插件",children:[]},{level:2,title:"打包体积",slug:"打包体积",children:[]},{level:2,title:"构建速度",slug:"构建速度",children:[]},{level:2,title:"其他优化",slug:"其他优化",children:[]},{level:2,title:"热更新",slug:"热更新",children:[{level:3,title:"webpack大纲",slug:"webpack大纲",children:[]}]}],filePathRelative:"Engineering/Webpack相关.md"}},5668:(l,n,e)=>{"use strict";e.r(n),e.d(n,{default:()=>rl});var a=e(6252);const u=e.p+"assets/img/webpack4.ed2eeb08.png",r=e.p+"assets/img/hotfix.64984708.png",m=e.p+"assets/img/webpack.2a952414.png",i=(0,a.Wm)("h1",{id:"webpack相关",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#webpack相关","aria-hidden":"true"},"#"),(0,a.Uk)(" Webpack相关")],-1),W=(0,a.Wm)("h2",{id:"webpack工作流程",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#webpack工作流程","aria-hidden":"true"},"#"),(0,a.Uk)(" webpack工作流程")],-1),o=(0,a.Wm)("p",null,[(0,a.Wm)("img",{src:u,alt:"webpack4工作流程"})],-1),t=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,"Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 Tapable，Webpack 中最核心的负责编译的 Compiler 和负责创建 bundles 的 Compilation 都是 Tapable 的子类，并且实例内部的生命周期也是通过 Tapable 库提供的钩子类实现的。")],-1),p=(0,a.Wm)("h2",{id:"loader和plugin的区别",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#loader和plugin的区别","aria-hidden":"true"},"#"),(0,a.Uk)(" Loader和Plugin的区别")],-1),c=(0,a.Wm)("p",null,[(0,a.Wm)("code",null,"Loader"),(0,a.Uk)(" 本质就是一个函数，"),(0,a.Wm)("strong",null,"在该函数中对接收到的内容进行转换，返回转换后的结果。"),(0,a.Uk)(" 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。")],-1),s=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,"css-loader"),(0,a.Uk)(" 将@import 和 url 处理成正规的ES6 import 使css文件模块化")],-1),k=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,"style-loader"),(0,a.Uk)(" 会将输出的css注入到打包文件中 （通过DOM操作将之前导出内容中的样式插入到style标签中）")],-1),d=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,"postcss-loader"),(0,a.Uk)(" 添加浏览器前缀")],-1),g=(0,a.Wm)("p",null,[(0,a.Wm)("code",null,"Plugin"),(0,a.Uk)(" 就是插件，基于事件流框架 "),(0,a.Wm)("code",null,"Tapable"),(0,a.Uk)("，"),(0,a.Wm)("strong",null,"插件可以扩展 Webpack 的功能"),(0,a.Uk)("，"),(0,a.Wm)("strong",null,"在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。")],-1),b=(0,a.Wm)("h3",{id:"在webpack的plugin运行的过程中存在两个非常重要的对象-compiler和compilation。",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#在webpack的plugin运行的过程中存在两个非常重要的对象-compiler和compilation。","aria-hidden":"true"},"#"),(0,a.Uk)(" 在webpack的plugin运行的过程中存在两个非常重要的对象："),(0,a.Wm)("code",null,"compiler"),(0,a.Uk)("和"),(0,a.Wm)("code",null,"compilation"),(0,a.Uk)("。")],-1),h=(0,a.Wm)("ul",null,[(0,a.Wm)("li",null,[(0,a.Wm)("p",null,"compiler：在初始化compiler对象之后，通过调用插件实例的apply方法，作为其参数传入。这个对象包含了webpack环境的所有的配置信息，比如options，loaders，plugins等。这个对象会在webpack被启动的时候进行实例化，全局且唯一的。")]),(0,a.Wm)("li",null,[(0,a.Wm)("p",null,"compilation：这个对象会作为plugin内置事件回调函数的参数。包含了当前的模块资源，编译生成的资源，变化的文件等信息。如果我们运行在开发模式，每当检测到一个文件的变化，就会生成一个新的compilation对象。")])],-1),U=(0,a.Wm)("p",null,"所以，compiler代表了webpack从启动到关闭的整个生命周期，而compilation仅仅代表了一次新的编译。",-1),w=(0,a.Wm)("h2",{id:"构建流程",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#构建流程","aria-hidden":"true"},"#"),(0,a.Uk)(" 构建流程")],-1),f=(0,a.Wm)("ol",null,[(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"初始化参数"),(0,a.Uk)("：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。")]),(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"开始编译"),(0,a.Uk)("：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。")]),(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"确定入口"),(0,a.Uk)("：根据配置中的 entry 找出所有的入口文件。")]),(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"编译模块"),(0,a.Uk)("：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。")]),(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"完成模块编译"),(0,a.Uk)("：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。")]),(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"输出资源"),(0,a.Uk)("：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。")]),(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"输出完成"),(0,a.Uk)("：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。")])],-1),P=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,"在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。")],-1),x=(0,a.Wm)("h2",{id:"提高效率的插件",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#提高效率的插件","aria-hidden":"true"},"#"),(0,a.Uk)(" 提高效率的插件")],-1),y=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"webpack-dashboard"),(0,a.Uk)("：可以更友好的展示相关打包信息。")])],-1),S=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"webpack-merge"),(0,a.Uk)("：提取公共配置，减少重复配置代码")])],-1),v=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"speed-measure-webpack-plugin"),(0,a.Uk)("：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。")])],-1),C=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"size-plugin"),(0,a.Uk)("：监控资源体积变化，尽早发现问题")])],-1),L=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"webpack-bundle-analyzer"),(0,a.Uk)(" 生成 "),(0,a.Wm)("code",null,"bundle"),(0,a.Uk)(" 的模块组成图，显示所占体积。")])],-1),J=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"HotModuleReplacementPlugin"),(0,a.Uk)("：模块热替换")])],-1),j=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"NamedModulesPlugin")]),(0,a.Uk)("："),(0,a.Wm)("strong",null,"显示热替换模块文件名称")],-1),D=(0,a.Wm)("p",null,[(0,a.Uk)("webpack 的一些优化手段，"),(0,a.Wm)("strong",null,"打包时间方面、缓存、缩小构建目标")],-1),T=(0,a.Wm)("h2",{id:"打包体积",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#打包体积","aria-hidden":"true"},"#"),(0,a.Uk)(" 打包体积")],-1),E=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,"打包体积优化，减少首次访问白屏时间"),(0,a.Uk)("：按需加载 "),(0,a.Wm)("strong",null,"code-splitting 代码切割"),(0,a.Uk)("：需要使用 "),(0,a.Wm)("code",null,"import()"),(0,a.Uk)(" 语法："),(0,a.Wm)("code",null,"import()"),(0,a.Uk)(" 语法，需要 "),(0,a.Wm)("code",null,"@babel/plugin-syntax-dynamic-import"),(0,a.Uk)(" 的插件支持，但是因为当前 "),(0,a.Wm)("code",null,"@babel/preset-env"),(0,a.Uk)(" 预设中已经包含了 "),(0,a.Wm)("code",null,"@babel/plugin-syntax-dynamic-import"),(0,a.Uk)("，因此我们不需要再单独安装和配置。")],-1),A=(0,a.Wm)("ol",null,[(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"externals配置")])],-1),H=(0,a.Wm)("p",null,[(0,a.Uk)("防止 "),(0,a.Wm)("strong",null,[(0,a.Uk)("将某些 "),(0,a.Wm)("code",null,"import"),(0,a.Uk)(" 的包(package)")]),(0,a.Uk)(" 打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies) --- "),(0,a.Wm)("strong",null,"CDN引入"),(0,a.Uk)("。")],-1),M=(0,a.Wm)("ol",{start:"2"},[(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"SplitChunksPlugin")])],-1),R=(0,a.Wm)("p",null,"页面公共资源：使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件",-1),z=(0,a.Wm)("ol",{start:"3"},[(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"使用Tree Shaking")])],-1),B=(0,a.Wm)("p",null,[(0,a.Uk)("ES6 模块化语法是静态的，可以静态分析=>需要使用"),(0,a.Wm)("strong",null,"UglifyJsPlugin"),(0,a.Uk)("插件")],-1),I=(0,a.Wm)("h2",{id:"构建速度",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#构建速度","aria-hidden":"true"},"#"),(0,a.Uk)(" 构建速度")],-1),O=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,"使用 DllPlugin"),(0,a.Uk)("："),(0,a.Wm)("strong",null,"DLLPlugin 和 DLLReferencePlugin 用某种方法实现了拆分 bundles，同时还大大提升了构建的速度。")],-1),N=(0,a.Wm)("ol",null,[(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"DllPlugin配置一份webpack配置文件，用于生成动态链接库。")])],-1),Y=(0,a.Wm)("p",null,[(0,a.Uk)("第一次使用 webpack.dll.config.js 文件会对第三方库打包，打包完成后就不会再打包它了，然后每次运行 webpack.config.js文件的时候，都会打包项目中本身的文件代码，当需要使用第三方依赖的时候，会"),(0,a.Wm)("strong",null,"使用 DllReferencePlugin插件去读取第三方依赖库"),(0,a.Uk)("，"),(0,a.Wm)("strong",null,"看看是否有该第三方库"),(0,a.Uk)("。所以说它的打包速度会得到一个很大的提升。）")],-1),_=(0,a.Wm)("ol",{start:"2"},[(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"使用 HappyPack或thread-loader")])],-1),q=(0,a.Wm)("p",null,[(0,a.Uk)("Webpack 是单线程模型的，也就是说 Webpack 需要一个一个地处理任务，"),(0,a.Wm)("strong",null,"不能同时处理多个任务"),(0,a.Uk)("。"),(0,a.Wm)("strong",null,"HappyPack将任务分解给多个子进程去并发执行"),(0,a.Uk)("，子进程处理完后再将结果发送给主进程,从而发挥多核 CPU 电脑的威力。")],-1),F=(0,a.Wm)("ol",{start:"3"},[(0,a.Wm)("li",null,[(0,a.Wm)("strong",null,"使用 ParallelUglifyPlugin")])],-1),G=(0,a.Wm)("p",null,[(0,a.Uk)("webpack默认提供了"),(0,a.Wm)("strong",null,"UglifyJS"),(0,a.Uk)("插件来压缩JS代码，但是它使用的是单线程压缩代码，也就是说多个js文件需要被压缩，它需要一个个文件进行压缩。所以说在正式环境打包压缩代码速度非常慢("),(0,a.Wm)("strong",null,"因为压缩JS代码需要先把代码解析成用Object抽象表示的AST语法树，再去应用各种规则分析和处理AST，导致这个过程耗时非常大"),(0,a.Uk)(")。")],-1),K=(0,a.Wm)("p",null,[(0,a.Uk)("当webpack有"),(0,a.Wm)("strong",null,"多个JS文件需要输出和压缩时候"),(0,a.Uk)("，原来会使用UglifyJS去一个个压缩并且输出，但是ParallelUglifyPlugin插件则会"),(0,a.Wm)("strong",null,"开启多个子进程"),(0,a.Uk)("，把对多个文件压缩的工作分别给多个子进程去完成，但是每个子进程还是通过UglifyJS去压缩代码。无非就是变成了"),(0,a.Wm)("strong",null,"并行处理"),(0,a.Uk)("该压缩了，并行处理多个子任务，效率会更加的提高。")],-1),Q=(0,a.Wm)("h2",{id:"其他优化",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#其他优化","aria-hidden":"true"},"#"),(0,a.Uk)(" 其他优化")],-1),V=(0,a.Wm)("p",null,[(0,a.Uk)("图片压缩--"),(0,a.Wm)("strong",null,"配置image-webpack-loader"),(0,a.Wm)("code",null,"缩小打包作用域"),(0,a.Uk)(" --exclude/include (确定 loader 规则范围)")],-1),X=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,"cache-loader"),(0,a.Uk)("--在一些"),(0,a.Wm)("strong",null,"性能开销较大"),(0,a.Uk)("的 loader 之前添加此 loader，以将结果缓存到磁盘里。")],-1),Z=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,"IgnorePlugin"),(0,a.Uk)("-- "),(0,a.Wm)("code",null,"webpack"),(0,a.Uk)(" 的内置插件，作用是忽略第三方包指定目录。")],-1),$={href:"https://juejin.cn/post/6844904071736852487",target:"_blank",rel:"noopener noreferrer"},ll=(0,a.Uk)("webpack优化"),nl=(0,a.Wm)("h2",{id:"热更新",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#热更新","aria-hidden":"true"},"#"),(0,a.Uk)(" 热更新")],-1),el=(0,a.Wm)("p",null,[(0,a.Wm)("img",{src:r,alt:"webpack热更新"})],-1),al=(0,a.Wm)("h3",{id:"webpack大纲",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#webpack大纲","aria-hidden":"true"},"#"),(0,a.Uk)(" webpack大纲")],-1),ul=(0,a.Wm)("p",null,[(0,a.Wm)("img",{src:m,alt:"webpack大纲"})],-1),rl={render:function(l,n){const e=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.j4)(a.HY,null,[i,W,o,t,p,c,s,k,d,g,b,h,U,w,f,P,x,y,S,v,C,L,J,j,D,T,E,A,H,M,R,z,B,I,O,N,Y,_,q,F,G,K,Q,V,X,Z,(0,a.Wm)("p",null,[(0,a.Wm)("a",$,[ll,(0,a.Wm)(e)])]),nl,el,al,ul],64)}}}}]);