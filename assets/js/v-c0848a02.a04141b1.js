(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8537],{3478:(e,r,t)=>{"use strict";t.r(r),t.d(r,{data:()=>a});const a={key:"v-c0848a02",path:"/Framework/React/Redux.html",title:"Redux",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"redux的一些理解",slug:"redux的一些理解",children:[{level:3,title:"createStore",slug:"createstore",children:[]},{level:3,title:"combineReducers",slug:"combinereducers",children:[]},{level:3,title:"applyMiddleware",slug:"applymiddleware",children:[]}]},{level:2,title:"react-redux是如何工作的",slug:"react-redux是如何工作的",children:[]}],filePathRelative:"Framework/React/Redux.md"}},1737:(e,r,t)=>{"use strict";t.r(r),t.d(r,{default:()=>d});const a=(0,t(6252).uE)('<h1 id="redux" tabindex="-1"><a class="header-anchor" href="#redux" aria-hidden="true">#</a> Redux</h1><h2 id="redux的一些理解" tabindex="-1"><a class="header-anchor" href="#redux的一些理解" aria-hidden="true">#</a> redux的一些理解</h2><p>redux的核心思想（工作流程）：</p><ul><li>将状态统一放在一个state中，由store来管理这个state。</li><li>这个store按照reducer的“shape”（形状）创建。</li><li>reducer的作用是接收到action后，输出一个新的状态，对应地更新store上的状态。</li><li>根据redux的原则指导，外部改变state的最佳方式是通过调用store的dispatch方法，触发一个action，这个action被对应的reducer处理，完成state更新。</li><li>可以通过subscribe在store上添加一个监听函数。每当调用dispatch方法时，会执行所有的监听函数。</li><li>可以添加中间件（中间件是干什么的我们后面讲）处理副作用。</li></ul><p>在这个工作流程中，redux需要提供的功能是：</p><ul><li>创建store，即：<code>createStore()</code></li><li>创建出来的store提供<code>subscribe</code>，<code>dispatch</code>，<code>getState</code>这些方法。</li><li>将多个reducer合并为一个reducer，即：<code>combineReducers()</code></li><li>应用中间件，即<code>applyMiddleware()</code></li></ul><h3 id="createstore" tabindex="-1"><a class="header-anchor" href="#createstore" aria-hidden="true">#</a> createStore</h3><p>函数内利用闭包的结构，只暴露了几个接口，增强了“封装性”（没有其他办法能接触到内部变量）</p><p>1.dispatch 调用reducer并触发所有的listener</p><p>2.subscribe 订阅state改变 返回的是一个取消订阅的方法</p><p>3.getState 获取store</p><p>4.replaceReducer 修改reducer</p><h3 id="combinereducers" tabindex="-1"><a class="header-anchor" href="#combinereducers" aria-hidden="true">#</a> combineReducers</h3><p>把子reducer合并成一个总的reducer （利用闭包绑定参数）</p><p>1.从参数reducers中筛选出有效的reducer</p><p>2.返回合并后的reducer</p><p><strong>combination</strong>：取得每个子reducer对应的state，与action一起作为参数给每个子reducer执行</p><p>调用reducer，根据状态是否改变返回新/旧state</p><h3 id="applymiddleware" tabindex="-1"><a class="header-anchor" href="#applymiddleware" aria-hidden="true">#</a> applyMiddleware</h3><p>输入为若干中间件，输出为enhancer</p><ol><li>调用（若干个）中间件函数，获取（若干个）改造函数 const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</li><li>把所有改造函数compose成一个改造函数 dispatch = compose(...chain)(store.dispatch)</li><li>改造dispatch方法 return { ...store, dispatch }</li></ol><p>compose：将多个函数参数转化成连续调用的函数形式</p><p>compose(fn1, fn2, fn3) (...args) = &gt; fn1(fn2(fn3(...args)))</p><h2 id="react-redux是如何工作的" tabindex="-1"><a class="header-anchor" href="#react-redux是如何工作的" aria-hidden="true">#</a> react-redux是如何工作的</h2><ul><li><strong>Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store</strong></li><li><strong>connect: 负责连接React和Redux</strong><ul><li><strong>获取state</strong>: connect通过context获取Provider中的store，通过store.getState()获取整个store tree 上所有state</li><li><strong>包装原组件</strong>: 将state和action通过props的方式传入到原组件内部wrapWithConnect返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件WrappedComponent，并把connect中传入的mapStateToProps, mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给WrappedComponent</li><li><strong>监听store tree变化</strong>: connect缓存了store tree中state的状态,通过当前state状态和变更前state状态进行比较,从而确定是否调用<code>this.setState()</code>方法触发Connect及其子组件的重新渲染</li></ul></li></ul>',25),d={render:function(e,r){return a}}}}]);