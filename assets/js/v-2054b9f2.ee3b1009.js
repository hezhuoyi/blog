(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9152],{4462:(e,l,t)=>{"use strict";t.r(l),t.d(l,{data:()=>u});const u={key:"v-2054b9f2",path:"/Framework/Vue/Vuex%E5%92%8CVue-Router.html",title:"Vuex和Vue-Router",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"关于vuex一些理解上的误区",slug:"关于vuex一些理解上的误区",children:[]},{level:2,title:"Store 实例化过程",slug:"store-实例化过程",children:[]},{level:2,title:"vue-router的理解",slug:"vue-router的理解",children:[]}],filePathRelative:"Framework/Vue/Vuex和Vue-Router.md"}},6604:(e,l,t)=>{"use strict";t.r(l),t.d(l,{default:()=>z});var u=t(6252);const n=t.p+"assets/img/vuex.261d644a.png",r=t.p+"assets/img/vue-router.367804be.png",o=(0,u.Wm)("h1",{id:"vuex和vue-router",tabindex:"-1"},[(0,u.Wm)("a",{class:"header-anchor",href:"#vuex和vue-router","aria-hidden":"true"},"#"),(0,u.Uk)(" Vuex和Vue-Router")],-1),a=(0,u.Wm)("h2",{id:"关于vuex一些理解上的误区",tabindex:"-1"},[(0,u.Wm)("a",{class:"header-anchor",href:"#关于vuex一些理解上的误区","aria-hidden":"true"},"#"),(0,u.Uk)(" 关于vuex一些理解上的误区")],-1),m=(0,u.Wm)("p",null,[(0,u.Wm)("strong",null,"1.vuex怎么注入到全局共享并实时更新的？")],-1),s=(0,u.Wm)("p",null,"通过vue.mixin将vuexInit注入beforeCreate",-1),i=(0,u.Wm)("p",null,[(0,u.Wm)("strong",null,"2.为什么mutation是同步的，action是异步的，且改变state只能通过mutation？")],-1),W=(0,u.Wm)("p",null,"非严格模式下可以直接手动直接修改state",-1),h=(0,u.Wm)("p",null,"区分 actions 和 mutations 并不是为了解决竞态问题，而是为了能用 devtools 追踪状态变化",-1),d=(0,u.Wm)("p",null,"actions 不是必须的，只是一个函数，想干啥都可以",-1),p=(0,u.Wm)("p",null,[(0,u.Wm)("strong",null,"actions 可以在不同模块中可以触发多个 action 函数 （源码中的entry.length>0的情况）")],-1),c=(0,u.Wm)("p",null,[(0,u.Wm)("strong",null,"mutation 必须是同步的 =>forEach执行每一个handler异步的话 顺序错乱 无法记录每一次变化（可能并不会出现bug）")],-1),g=(0,u.Wm)("p",null,[(0,u.Wm)("img",{src:n,alt:"vuex"})],-1),k=(0,u.Wm)("p",null,[(0,u.Wm)("strong",null,"3.刷新 => 清空")],-1),v=(0,u.Wm)("p",null,"javascript的代码都是运行在内存的，刷新页面，以前申请的内存会被释放，重新加载脚本代码，变量重新赋值。",-1),U=(0,u.Wm)("h2",{id:"store-实例化过程",tabindex:"-1"},[(0,u.Wm)("a",{class:"header-anchor",href:"#store-实例化过程","aria-hidden":"true"},"#"),(0,u.Uk)(" Store 实例化过程")],-1),x=(0,u.Wm)("p",null,"1.初始化模块（modules）=>2.安装模块(对模块中的 state、getters、mutations、actions 做初始化工作)=>3.初始化store._vm（通过Vue使store做到响应式）",-1),f=(0,u.Wm)("p",null,[(0,u.Uk)("1.每个子模块通过路径找到它的父模块，然后通过父模块的 "),(0,u.Wm)("code",null,"addChild"),(0,u.Uk)(" 方法建立父子关系，递归执行这样的过程，建立一颗完整的模块树。")],-1),V=(0,u.Wm)("p",null,"2.通过递归遍历的方式，完成所有子模块的安装工作 forEachMutation forEachAction forEachGetter forEachChild",-1),b=(0,u.Wm)("p",null,[(0,u.Uk)("3.resetStoreVM 想建立 "),(0,u.Wm)("code",null,"getters"),(0,u.Uk)(" 和 "),(0,u.Wm)("code",null,"state"),(0,u.Uk)(" 的联系 利用了 Vue 中用 "),(0,u.Wm)("code",null,"computed"),(0,u.Uk)(" 计算属性来实现")],-1),w=(0,u.Wm)("p",null,[(0,u.Wm)("strong",null,"Vuex的双向绑定通过调用 new Vue实现，然后通过 Vue.mixin 注入到Vue组件的生命周期中，再通过劫持state.get将数据放入组件中")],-1),y=(0,u.Wm)("h2",{id:"vue-router的理解",tabindex:"-1"},[(0,u.Wm)("a",{class:"header-anchor",href:"#vue-router的理解","aria-hidden":"true"},"#"),(0,u.Uk)(" vue-router的理解")],-1),R=(0,u.Wm)("p",null,"Vue 从它的设计上就是一个渐进式 JavaScript 框架，它本身的核心是解决视图渲染的问题，其它的能力就通过插件的方式来解决。Vue-Router 就是官方维护的路由插件。",-1),S=(0,u.Wm)("ol",null,[(0,u.Wm)("li",null,[(0,u.Wm)("p",null,[(0,u.Uk)("通过标志位为了确保 "),(0,u.Wm)("code",null,"install"),(0,u.Uk)(" 逻辑只执行一次。")])]),(0,u.Wm)("li",null,[(0,u.Wm)("p",null,[(0,u.Uk)("利用 "),(0,u.Wm)("code",null,"Vue.mixin"),(0,u.Uk)(" 去把 "),(0,u.Wm)("code",null,"beforeCreate"),(0,u.Uk)(" 和 "),(0,u.Wm)("code",null,"destroyed"),(0,u.Uk)(" 钩子函数注入到每一个组件中。在 "),(0,u.Wm)("code",null,"beforeCreate"),(0,u.Uk)(" 做一些私有属性定义和路由初始化工作。")])]),(0,u.Wm)("li",null,[(0,u.Wm)("p",null,"VueRouter 的实现是一个类，初始化时通过mode新建了不同的history类，init时调用了history.transitionTo做路由过渡。")])],-1),C=(0,u.Wm)("p",null,[(0,u.Wm)("strong",null,"hash模式")],-1),E=(0,u.Wm)("p",null,[(0,u.Uk)("hash模式的工作原理是"),(0,u.Wm)("strong",null,"hashchange事件，可以在window监听hash的变化"),(0,u.Uk)("。我们在url后面随便添加一个#xx触发这个事件，"),(0,u.Wm)("strong",null,"页面不会发生跳转"),(0,u.Uk)("。")],-1),P=(0,u.Wm)("p",null,[(0,u.Wm)("strong",null,"history模式")],-1),T=(0,u.Wm)("p",null,[(0,u.Uk)("这种模式充分利用 "),(0,u.Wm)("code",null,"history.pushState"),(0,u.Uk)(" API 来"),(0,u.Wm)("strong",null,"完成 URL 跳转而无须重新加载页面"),(0,u.Uk)("。")],-1),j=(0,u.Wm)("p",null,[(0,u.Wm)("strong",null,"history.pushState()主要是在不刷新浏览器的情况下，创建新的浏览记录并插入浏览记录队列中。")],-1),A=(0,u.Wm)("p",null,"原先api：go back forward",-1),H=(0,u.Wm)("p",null,[(0,u.Uk)("HTML5新增的historyAPI有3样武器，"),(0,u.Wm)("strong",null,"history.pushState(stateObject, title, url)、history.replaceState()、window.onpopstate"),(0,u.Uk)(" 分别能够在浏览器history对象中偷偷的生成一条新的历史记录(不发送请求)，替换一条历史记录(不发送请求)，当前进后退history到前两者的留下的历史记录时做出反应。")],-1),I=(0,u.Wm)("p",null,"因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问http://www.yongcun.wang/tclass就会返回 404，这就不好看了。",-1),L=(0,u.Wm)("p",null,[(0,u.Uk)("所以呢，"),(0,u.Wm)("strong",null,"你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。")],-1),M=(0,u.Wm)("p",null,[(0,u.Wm)("img",{src:r,alt:"vue-router"})],-1),F=(0,u.Wm)("p",null,"nginx--高性能的HTTP和反向代理web服务器",-1),_=(0,u.Wm)("p",null,"try_files 按顺序检查文件是否存在，返回第一个找到的文件。结尾的斜线表示为文件夹 -$uri/。如果所有的文件都找不到，会进行一个内部重定向到最后一个参数。",-1),z={render:function(e,l){return(0,u.wg)(),(0,u.j4)(u.HY,null,[o,a,m,s,i,W,h,d,p,c,g,k,v,U,x,f,V,b,w,y,R,S,C,E,P,T,j,A,H,I,L,M,F,_],64)}}}}]);