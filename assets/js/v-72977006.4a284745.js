(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7651],{7443:(e,o,r)=>{"use strict";r.r(o),r.d(o,{data:()=>t});const t={key:"v-72977006",path:"/Browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.html",title:"浏览器缓存",lang:"zh-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Http缓存",slug:"http缓存",children:[{level:3,title:"1.1强缓存",slug:"_1-1强缓存",children:[]},{level:3,title:"1.2协商缓存",slug:"_1-2协商缓存",children:[]},{level:3,title:"1.3缓存位置（优先级）",slug:"_1-3缓存位置-优先级",children:[]}]},{level:2,title:"浏览器的本地存储",slug:"浏览器的本地存储",children:[{level:3,title:"2.1 Cookie",slug:"_2-1-cookie",children:[]},{level:3,title:"2.2 localStorage",slug:"_2-2-localstorage",children:[]},{level:3,title:"2.3 sessionStorage",slug:"_2-3-sessionstorage",children:[]},{level:3,title:"2.4 IndexedDB",slug:"_2-4-indexeddb",children:[]}]}],filePathRelative:"Browser/浏览器缓存.md"}},3097:(e,o,r)=>{"use strict";r.r(o),r.d(o,{default:()=>d});const t=(0,r(6252).uE)('<h1 id="浏览器缓存" tabindex="-1"><a class="header-anchor" href="#浏览器缓存" aria-hidden="true">#</a> 浏览器缓存</h1><h2 id="http缓存" tabindex="-1"><a class="header-anchor" href="#http缓存" aria-hidden="true">#</a> Http缓存</h2><h3 id="_1-1强缓存" tabindex="-1"><a class="header-anchor" href="#_1-1强缓存" aria-hidden="true">#</a> 1.1强缓存</h3><p>浏览器中的缓存作用分为两种情况，一种是需要发送<code>HTTP</code>请求，一种是不需要发送。</p><p>首先是检查强缓存，这个阶段<strong>不需要发送HTTP请求</strong>。</p><p><strong>Expires（HTTP/1） =&gt; Cache-Control（HTTP/1.1） 从过期时间变成过期时长</strong><br> Cache-control: max-age=30 该属性值表示资源会在 30 秒后过期，需要再次请求。Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令。</p><h3 id="_1-2协商缓存" tabindex="-1"><a class="header-anchor" href="#_1-2协商缓存" aria-hidden="true">#</a> 1.2协商缓存</h3><p>强缓存失效之后，浏览器在请求头中携带相应的<code>缓存tag</code>来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是<strong>协商缓存</strong>。两种tag： <strong>Last-Modified</strong> （最后修改时间）和 <strong>ETag</strong>（文件生成的唯一标识）</p><p>Last-Modified 存在一些弊端：</p><ol><li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</li><li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li></ol><p><strong>Etag / If-None-Match （优先级高） 或者Last-Modified / If-Modified-Since</strong></p><p>在<code>精准度</code>上，<code>ETag</code>优于<code>Last-Modified</code> ，在性能上，<code>Last-Modified</code>优于<code>ETag</code></p><h3 id="_1-3缓存位置-优先级" tabindex="-1"><a class="header-anchor" href="#_1-3缓存位置-优先级" aria-hidden="true">#</a> 1.3缓存位置（优先级）</h3><ol><li><strong>Service Worker 浏览器在后台独立于网页运行的脚本</strong></li></ol><p>让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问<code>DOM</code>。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如<code>离线缓存</code>、<code>消息推送</code>和<code>网络代理</code>等功能。其中的<code>离线缓存</code>就是 <strong>Service Worker Cache</strong>。Service Worker 同时也是 PWA 的重要实现机制，</p><ol start="2"><li><p><strong>Memory Cache 内存缓存</strong> 最快最短</p></li><li><p><strong>Disk Cache 磁盘中的缓存</strong> 最慢最长</p></li><li><p><strong>Push Cache 推送缓存</strong></p></li></ol><h2 id="浏览器的本地存储" tabindex="-1"><a class="header-anchor" href="#浏览器的本地存储" aria-hidden="true">#</a> 浏览器的本地存储</h2><h3 id="_2-1-cookie" tabindex="-1"><a class="header-anchor" href="#_2-1-cookie" aria-hidden="true">#</a> 2.1 Cookie</h3><p><strong>容量缺陷。</strong> Cookie 的体积上限只有<code>4KB</code>，只能用来存储少量的信息。</p><p><strong>性能缺陷。</strong> Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实<strong>会造成巨大的性能浪费的，因为请求携带了很多不必要的内容</strong>。</p><p><strong>安全缺陷。</strong> 由于 Cookie 以<strong>纯文本</strong>的形式<strong>在浏览器和服务器中传递</strong>，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。</p><h3 id="_2-2-localstorage" tabindex="-1"><a class="header-anchor" href="#_2-2-localstorage" aria-hidden="true">#</a> 2.2 localStorage</h3><p><strong>容量</strong>。localStorage 的容量上限为<strong>5M</strong>，相比于<code>Cookie</code>的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是<strong>持久存储</strong>的。</p><p><strong>只存在客户端，默认不参与与服务端的通信</strong>。这样就很好地避免了 Cookie 带来的<strong>性能问题</strong>和<strong>安全问题</strong>。</p><p><strong>接口封装</strong>。通过<code>localStorage</code>暴露在全局，并通过它的 <code>setItem</code> 和 <code>getItem</code>等方法进行操作，非常方便。</p><h3 id="_2-3-sessionstorage" tabindex="-1"><a class="header-anchor" href="#_2-3-sessionstorage" aria-hidden="true">#</a> 2.3 sessionStorage</h3><p><code>sessionStorage</code>和<code>localStorage</code>有一个本质的区别，那就是前者只是<strong>会话级别的存储</strong>，并不是持久化存储。会话结束，也就是页面关闭，这部分<code>sessionStorage</code>就不复存在了。</p><p>其他同上。</p><h3 id="_2-4-indexeddb" tabindex="-1"><a class="header-anchor" href="#_2-4-indexeddb" aria-hidden="true">#</a> 2.4 IndexedDB</h3><p><code>IndexedDB</code>是运行在浏览器中的<code>非关系型数据库</code>, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。</p><p><strong>支持事务，存储二进制数据，键值对存储。异步操作。受同源策略限制，即无法访问跨域的数据库。</strong></p>',31),d={render:function(e,o){return t}}}}]);